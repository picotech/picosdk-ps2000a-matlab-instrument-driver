<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>2.42</FileVersion>
   <DriverName>picotech_ps2000a_generic.mdd</DriverName>
   <DriverType>MATLAB generic</DriverType>
   <InstrumentType>Oscilloscope</InstrumentType>
   <InstrumentManufacturer>Pico Technology Ltd.</InstrumentManufacturer>
   <InstrumentModel>PicoScope 2000 Series (A API)</InstrumentModel>
   <InstrumentVersion>1.2.33</InstrumentVersion>
   <Identify/>
   <Reset/>
   <Selftest/>
   <Error/>
   <CreateInitCode>
      <Code>function init(obj)
% This function is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

% Copyright © 2014-2018 Pico Technology Ltd. All rights reserved.
% You may copy and distribute this fiitsle as long as it remains unmodified. 
% SB
    
    fprintf('PicoScope 2000 Series (A API) MATLAB Instrument Driver\n\n');
    fprintf('Copyright © 2014-2018 Pico Technology Ltd. All rights reserved.\n');
    fprintf('\n');
    
    fprintf('\n');

    % Load libraries
    % ==============
    
    % Indentify architecture and obtain function handle for the correct
    % prototype file.
    
    archStr = computer('arch');
    
    ps2000aMFile = str2func(strcat('ps2000aMFile_', archStr));
    ps2000aWrapMFile = str2func(strcat('ps2000aWrapMFile_', archStr));
    
    % Only load library once 
    if(libisloaded('ps2000a'))
       
        % Do nothing
        
    else
       
        if (ismac())
            
            [ps2000aNotFound, ps2000aWarnings] = loadlibrary('libps2000a.dylib', ps2000aMFile, 'alias', 'ps2000a');
            
        elseif (isunix())
                
            [ps2000aNotFound, ps2000aWarnings] = loadlibrary('libps2000a.so', ps2000aMFile, 'alias', 'ps2000a');
            
        elseif (ispc())
            
            [ps2000aNotFound, ps2000aWarnings] = loadlibrary('ps2000a.dll', ps2000aMFile);
                
        else
            
            % Do nothing
        
        end
        
    end
    
    % Only load library once 
    if (libisloaded('ps2000aWrap'))

        % Do nothing
        
    else
        
        if (ismac())
            
            [ps2000aWrapNotFound, ps2000aWrapWarnings] = loadlibrary('libps2000aWrap.dylib', ps2000aWrapMFile, 'alias', 'ps2000aWrap');
            
        elseif (isunix())   

            [ps2000aWrapNotFound, ps2000aWrapWarnings] = loadlibrary('libps2000aWrap.so', ps2000aWrapMFile, 'alias', 'ps2000aWrap');
        
        elseif (ispc())
            
            [ps2000aWrapNotFound, ps2000aWrapWarnings] = loadlibrary('ps2000aWrap.dll', ps2000aWrapMFile);
                
        else
            
            % Do nothing
           
        end
        
    end
    
    % Load in enumeration and structure information
    % =============================================
    
    [~, obj.DriverData.structs, obj.DriverData.enums, ~] = ps2000aMFile(); 
    [~, ~, obj.DriverData.wrapEnums, ~] = ps2000aWrapMFile();
    
    
    % Define constant values used by this Instrument Driver
    % =====================================================
    
    % Constants from ps2000aApi.h header file
    % ---------------------------------------
    
    % ETS Mode
    obj.DriverData.constants.PS2208_MAX_ETS_CYCLES	= 500;
    obj.DriverData.constants.PS2208_MAX_INTERLEAVE	= 20;

    obj.DriverData.constants.PS2207_MAX_ETS_CYCLES	= 500;
    obj.DriverData.constants.PS2207_MAX_INTERLEAVE	= 20;

    obj.DriverData.constants.PS2206_MAX_ETS_CYCLES	= 250;
    obj.DriverData.constants.PS2206_MAX_INTERLEAVE	= 10;

    % External Channel ADC Count
    obj.DriverData.constants.PS2000A_EXT_MAX_VALUE      = 32767;
    obj.DriverData.constants.PS2000A_EXT_MIN_VALUE      = -32767;

    obj.DriverData.constants.PS2000A_EXT_MAX_VOLTAGE    = 5;
    obj.DriverData.constants.PS2000A_EXT_MIN_VOLTAGE    = -5;

    obj.DriverData.constants.PS2000A_MAX_LOGIC_LEVEL	= 32767;
    obj.DriverData.constants.PS2000A_MIN_LOGIC_LEVEL    = -32767;

    obj.DriverData.constants.PS2000A_MAX_LOGIC_VOLTAGE  = 5;
    obj.DriverData.constants.PS2000A_MIN_LOGIC_VOLTAGE  = -5;

    % Function/Arbitrary Waveform Parameters
    obj.DriverData.constants.MIN_SIG_GEN_FREQ = 0.0;
    obj.DriverData.constants.MAX_SIG_GEN_FREQ = 20000000.0;

    obj.DriverData.constants.PS2000A_MAX_SIG_GEN_BUFFER_SIZE = 8192;
    obj.DriverData.constants.PS2000A_MIN_SIG_GEN_BUFFER_SIZE = 1;

    obj.DriverData.constants.MIN_DWELL_COUNT	= 3;
    obj.DriverData.constants.MAX_SWEEPS_SHOTS	= pow2(30) - 1; %1073741823

    obj.DriverData.constants.MAX_ANALOGUE_OFFSET_50MV_200MV = 0.250;
    obj.DriverData.constants.MIN_ANALOGUE_OFFSET_50MV_200MV = -0.250;
    obj.DriverData.constants.MAX_ANALOGUE_OFFSET_500MV_2V   = 2.500;
    obj.DriverData.constants.MIN_ANALOGUE_OFFSET_500MV_2V   = -2.500;
    obj.DriverData.constants.MAX_ANALOGUE_OFFSET_5V_20V     = 20;
    obj.DriverData.constants.MIN_ANALOGUE_OFFSET_5V_20V     = -20; 

    % Supported by all models except the PicoScope 2205 MSO
    obj.DriverData.constants.PS2000A_SHOT_SWEEP_TRIGGER_CONTINUOUS_RUN = hex2dec('FFFFFFFF');

    % DDS Frequencies
    
    obj.DriverData.constants.PS2205MSO_AWG_DDS_FREQUENCY = 48e6; % DDS Frequency of 48 MHz (PicoScope 2205MSO only).
    obj.DriverData.constants.PS2000A_AWG_DDS_FREQUENCY = 20e6; % DDS Frequency of 20 MHz (other models).

    % Signal Generator Max. Frequencies

    obj.DriverData.constants.PS2000A_SINE_MAX_FREQUENCY         = 1000000;
    obj.DriverData.constants.PS2000A_SQUARE_MAX_FREQUENCY       = 1000000;
    obj.DriverData.constants.PS2000A_TRIANGLE_MAX_FREQUENCY     = 1000000;
    obj.DriverData.constants.PS2000A_SINC_MAX_FREQUENCY         = 1000000;
    obj.DriverData.constants.PS2000A_RAMP_MAX_FREQUENCY         = 1000000;
    obj.DriverData.constants.PS2000A_HALF_SINE_MAX_FREQUENCY	= 1000000;
    obj.DriverData.constants.PS2000A_GAUSSIAN_MAX_FREQUENCY     = 1000000;
    obj.DriverData.constants.PS2000A_PRBS_MAX_FREQUENCY         = 1000000;
    obj.DriverData.constants.PS2000A_PRBS_MIN_FREQUENCY         = 0.03;
    obj.DriverData.constants.PS2000A_MIN_FREQUENCY              = 0.03;

    % Maximum number of devices using this driver
    % -------------------------------------------
    
    obj.DriverData.constants.PS2000A_MAX_UNITS = 64;
    
    % PicoScope 2000 Series models using the 'A' API
    % ----------------------------------------------

     obj.DriverData.variants.MODEL_NONE      = 'NONE';

    % 2-channel variants

    obj.DriverData.variants.MODEL_PS2206        = '2206';
    obj.DriverData.variants.MODEL_PS2206A       = '2206A';
    obj.DriverData.variants.MODEL_PS2206B       = '2206B';
    obj.DriverData.variants.MODEL_PS2207        = '2207';
    obj.DriverData.variants.MODEL_PS2207A       = '2207A';
    obj.DriverData.variants.MODEL_PS2207B       = '2207B';
    obj.DriverData.variants.MODEL_PS2208        = '2208';
    obj.DriverData.variants.MODEL_PS2208A       = '2208A';
    obj.DriverData.variants.MODEL_PS2208B       = '2208B';

    % 4-channel variants

    obj.DriverData.variants.MODEL_2405A         = '2405A';
    obj.DriverData.variants.MODEL_2406B         = '2406B';
    obj.DriverData.variants.MODEL_2407B         = '2407B';
    obj.DriverData.variants.MODEL_2408B         = '2408B';

    % Mixed Signal Oscilloscope variants

    obj.DriverData.variants.MODEL_PS2205MSO     = '2205MSO';
    obj.DriverData.variants.MODEL_PS2205AMSO    = '2205AMSO';
    obj.DriverData.variants.MODEL_PS2206BMSO    = '2206BMSO';
    obj.DriverData.variants.MODEL_PS2207BMSO    = '2207BMSO';
    obj.DriverData.variants.MODEL_PS2208BMSO    = '2208BMSO';
        
    
    % Obtain flag to indicate if functions should output text to Command
    % Window
    % -------------------------------
    
    obj.DriverData.displayOutput = obj.displayOutput;
    
    % Enumerate units 
    % ---------------
    
    % only displayed if driver is being used via command line
    
    count = int16(0);
    serials = blanks(100);
    serialLth = int16(100);
    
    [status, count, serials, serialLth] = calllib('ps2000a', ...
        'ps2000aEnumerateUnits',  count, serials, serialLth);
    
    if (status == PicoStatus.PICO_OK)
        
        fprintf('Number of units found: %d\n\nSerial number(s): %s\n\n', count, serials); 
        
    elseif (status == PicoStatus.PICO_NOT_FOUND)
        
        error('No units found.');
        
    else
        
        error('Status code: %d\n', status);
        
    end
    </Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This function is called after the object is connected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

% Copyright © 2014-2018 Pico Technology Ltd. All rights reserved.
% You may copy and distribute this file as long as it remains unmodified.

    disp('Opening PicoScope 2000 Series (A API) device...');
    
    % Structure to hold status values while connecting to the device.
    % Only output when the driver is called using command line or script.
    connectStatus = [];

    % Temporary variable to store handle value
    unitHandle = 0;
    
    % PICO_OK status value (0)
    picoOK = PicoStatus.PICO_OK;

    % Obtain the serial input
    serialNum = get(obj, 'RsrcName');

    % Determine if serial number is specified or null
    if(isempty(serialNum))

        unitSerial = [];

    else

        unitSerial = serialNum;

    end

    % Open the unit
    [connectStatus.openUnit, unitHandle] = ...
        calllib('ps2000a', 'ps2000aOpenUnit', unitHandle, unitSerial);

    obj.DriverData.unitHandle = unitHandle;
    
    % Initialise matrix channel settings
    % Setup initial channel settings (4 x 4)
    % 4 channels consisting of enabled, coupling, range, analogue offset
    % Default will be set later via resetDevice
    
    obj.DriverData.channelSettings = zeros(PicoConstants.QUAD_SCOPE, 4);
    
    % Initialise matrix for digital port settings
    % Setup initial channel settings (4 x 2)
    % 2 channels consisting of enabled state and logic level
    % Default will be set later via resetDevice
    
    obj.DriverData.digitalPortSettings = zeros(PicoConstants.QUAD_SCOPE, 2)
   
    % Set handle and serial 
    % Unit connected if 0
    if(connectStatus.openUnit == picoOK)
        
        fprintf('Setting Device Parameters...\n\n');
        
        % Set handle internally
        unitHandle = obj.DriverData.unitHandle;

        % Retrieve device serial number
        infoLine = blanks(40);
        reqSize = 40;

        [connectStatus.unit_serial, unitSerial, reqSize]  = calllib('ps2000a', ...
                'ps2000aGetUnitInfo', unitHandle, infoLine, ... 
                length(infoLine), reqSize, PicoStatus.PICO_BATCH_AND_SERIAL);

        obj.DriverData.unitSerial = unitSerial;

        % Retrieve device model number
        infoLineV = blanks(40);
        reqSizeV = 40;
        
        [connectStatus.unit_variant, variant, reqSizeV]  = calllib('ps2000a', ...
                'ps2000aGetUnitInfo', unitHandle, infoLineV, ... 
                length(infoLineV), reqSizeV, PicoStatus.PICO_VARIANT_INFO);

        set(obj, 'InstrumentModel', variant);        
        
        % Set Device Properties
        % ---------------------
        
        % Max/min voltage ranges
        range20mV   = obj.DriverData.enums.enPS2000ARange.PS2000A_20MV;
        range50mV   = obj.DriverData.enums.enPS2000ARange.PS2000A_50MV;
        range20V    = obj.DriverData.enums.enPS2000ARange.PS2000A_20V;

        % Obtain channel count
        obj.DriverData.channelCount = str2num(obj.InstrumentModel(2));

        % Set first range enumeration
        if(obj.DriverData.channelCount == 2)
        
            % Original 2206/7/8 models (including 'A' variants)
            if(length(obj.InstrumentModel) == 4 || ...
                (length(obj.InstrumentModel) == 5) &amp;&amp; strcmpi(obj.InstrumentModel(5), 'A') || ...
                strcmpi(obj.InstrumentModel, obj.DriverData.variants.MODEL_PS2205MSO))
           
                obj.DriverData.firstRange = range50mV;
            
            else
            
                % All other 2-channel models ('B' variant and MSO products)
                obj.DriverData.firstRange = range20mV;
            
            end
        
        elseif(obj.DriverData.channelCount == 4)
        
            obj.DriverData.firstRange = range20mV;
        
        else
        
            % Do nothing
            
        end
        
        obj.DriverData.lastRange = range20V;
        
        % Inform the wrapper dll of the number of analogue channels on the device
        status = calllib('ps2000aWrap', 'setChannelCount', obj.DriverData.unitHandle);

        % Set the max. ADC value

        maxValue = 0;

        [maxValueStatus, obj.DriverData.maxADCValue]  = calllib('ps2000a', ...
            'ps2000aMaximumValue', obj.DriverData.unitHandle, maxValue);

        clear maxValue;
        clear maxValueStatus;

        % Set the min. ADC value

        minValue = 0;

        [minValueStatus, obj.DriverData.minADCValue]  = calllib('ps2000a', ...
            'ps2000aMinimumValue', obj.DriverData.unitHandle, minValue);

        clear minValue;
        clear minValueStatus;
        
        % Maximum ETS Cycles - 500 unless otherwise specified below
        obj.DriverData.maxEtsCycles = 500;

        % Set bandwidth and buffer memory information
        switch obj.InstrumentModel

            case obj.DriverData.variants.MODEL_PS2206
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_50MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_24KS;
                obj.DriverData.maxEtsCycles = obj.DriverData.constants.PS2206_MAX_ETS_CYCLES;
                
            case obj.DriverData.variants.MODEL_PS2206A
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_50MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_32KS;
                obj.DriverData.maxEtsCycles = obj.DriverData.constants.PS2206_MAX_ETS_CYCLES;
                
            case obj.DriverData.variants.MODEL_PS2206B
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_50MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_32MS;
                
            case obj.DriverData.variants.MODEL_PS2207
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_32KS;
                obj.DriverData.maxEtsCycles = obj.DriverData.constants.PS2207_MAX_ETS_CYCLES;
                
            case obj.DriverData.variants.MODEL_PS2207A
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_40KS;
                obj.DriverData.maxEtsCycles = obj.DriverData.constants.PS2207_MAX_ETS_CYCLES;
                
            case obj.DriverData.variants.MODEL_PS2207B
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_70MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_64MS;
                
            case obj.DriverData.variants.MODEL_PS2208
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_200MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_40KS;
                obj.DriverData.maxEtsCycles = obj.DriverData.constants.PS2208_MAX_ETS_CYCLES;
                
            case obj.DriverData.variants.MODEL_PS2208A
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_200MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_48KS;
                obj.DriverData.maxEtsCycles = obj.DriverData.constants.PS2208_MAX_ETS_CYCLES;
                
            case obj.DriverData.variants.MODEL_PS2208B
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_128MS;
                
            case obj.DriverData.variants.MODEL_2405A
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_25MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_48KS;
                
            case obj.DriverData.variants.MODEL_2406B
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_50MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_32MS;
                
            case obj.DriverData.variants.MODEL_2407B    
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_64MS;
                
            case obj.DriverData.variants.MODEL_2408B
             
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_200MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_128MS;
                
            case obj.DriverData.variants.MODEL_PS2205MSO
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_25MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_48KS;
                
            case obj.DriverData.variants.MODEL_PS2205AMSO
                    
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_25MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_48KS;
                
            case obj.DriverData.variants.MODEL_PS2206BMSO
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_50MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_32MS;
                
            case obj.DriverData.variants.MODEL_PS2207BMSO    
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_100MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_64MS;
                
            case obj.DriverData.variants.MODEL_PS2208BMSO    
                
                obj.DriverData.bandwidth = PicoConstants.BANDWIDTH_200MHZ;
                obj.DriverData.bufferMemory = PicoConstants.BUFFER_MEMORY_128MS;
                
            otherwise

                obj.DriverData.bandwidth = 0;
                obj.DriverData.bufferMemory = 0;

        end
        
        % Determine if device is an MSO
        isMSO = strfind(obj.InstrumentModel, 'MSO');

        if (~isempty(isMSO))

            obj.DriverData.digitalPortCount = 2;

        else

            obj.DriverData.digitalPortCount = 0;

        end
        
        % Set the max AWG Buffer Size if the device has an AWG
        obj.DriverData.awgBufferSize = 0;

        [~, ~,~, ~, obj.DriverData.awgBufferSize] = calllib('ps2000a', ...
            'ps2000aSigGenArbitraryMinMaxValues', obj.DriverData.unitHandle, ...
                0, 0, 0, obj.DriverData.awgBufferSize);

        if(obj.DriverData.awgBufferSize &gt; 0)

            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_AWG;

        else

            obj.DriverData.sigGenType = PicoConstants.SIG_GEN_FUNCT_GEN;

        end

        % Set the DDS Frequency and maximum sampling rate 
        if(strcmpi(obj.InstrumentModel, obj.DriverData.variants.MODEL_PS2205MSO))

           obj.DriverData.ddsFrequency = obj.DriverData.constants.PS2205MSO_AWG_DDS_FREQUENCY;
           obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_200MSPS;

        else

            obj.DriverData.ddsFrequency = obj.DriverData.constants.PS2000A_AWG_DDS_FREQUENCY;

            % Maximum sampling rate varies for the 
            % 2405 and 2206A/B variants plus the 2205A MSO
            if (~isempty(strfind(obj.InstrumentModel, '2405')) || ...
                strcmp(obj.InstrumentModel, obj.DriverData.variants.MODEL_PS2206A) || ...
                strcmp(obj.InstrumentModel, obj.DriverData.variants.MODEL_PS2206B) || ...
                strcmp(obj.InstrumentModel, obj.DriverData.variants.MODEL_PS2205AMSO))

                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_500MSPS;

            else

                obj.DriverData.maxSamplingRate = PicoConstants.MAX_SAMPLING_RATE_1GSPS;

            end

        end

        obj.DriverData.hasHardwareEts = 0; % Software ETS
        
        
        if(obj.DriverData.digitalPortCount &gt; 0)
           
            obj.DriverData.maxLogicLevel = obj.DriverData.constants.PS2000A_MAX_LOGIC_LEVEL;
            obj.DriverData.minLogicLevel = obj.DriverData.constants.PS2000A_MIN_LOGIC_LEVEL;
            
        else
            
            obj.DriverData.maxLogicLevel = 0;
            obj.DriverData.minLogicLevel = 0;
            
        end
        
        % Other device parameters
        
        obj.DriverData.autoTriggerMs = 0;
        obj.DriverData.delay = 0;

        % Set the default number of pre-trigger and post-trigger samples
        obj.DriverData.numPreTriggerSamples = 0;
        obj.DriverData.numPostTriggerSamples = 8192;

        % Set the timebase - default of 64 corresponds to following sampling intervals:
        %   500MS/s models - 992ns
        %   1 GS/s models  - 496ns
        %   2205 MSO       - 640ns
        %
        obj.DriverData.timebase = 64;

        obj.DriverData.streamingInterval = 1e-6; % 1us -&gt; 1MS/s
        obj.DriverData.autoStop = 1;

        obj.DriverData.startFrequency = 1000;
        obj.DriverData.stopFrequency = 1000;
        obj.DriverData.offsetVoltage = 0;
        obj.DriverData.peakToPeakVoltage = 2000;
        
        % Set whether to display output
        obj.DriverData.displayOutput = PicoConstants.TRUE;
        
        % Set device defaults for channels, ETS, trigger, block and
        % streaming mode data collection as well as signal generator.
        invoke(obj, 'resetDevice');
        
        disp('Initialisation complete.');
        
        % Display unit information to user if not using TMTool
        fprintf('\n');
        fprintf('Connected to PicoScope 2000 Series (A API) device:-\n\n');
        fprintf('      Instrument Model: %s\n', get(obj, 'InstrumentModel'));
        fprintf('   Batch/Serial Number: %s\n', unitSerial);
        fprintf('       Analog Channels: %d\n', obj.DriverData.channelCount);
        
        if(obj.DriverData.digitalPortCount &gt; 0)
           
            fprintf('      Digital Channels: %d\n', obj.DriverData.digitalPortCount * 8);
            
        end
            
        % Bandwidth information
        bandwidthHz = obj.DriverData.bandwidth;
        
        if(bandwidthHz &gt; 0 &amp;&amp; bandwidthHz &lt; 1e9)
            
           fprintf('             Bandwidth: %d MHz\n', (bandwidthHz/1e6));
           
        elseif(bandwith_hz &gt;= 1e9)
            
           fprintf('             Bandwidth: %d GHz\n', (bandwidthHz/1e9));
           
        else
            
            % Do nothing
            
        end
        
        if(obj.DriverData.bufferMemory &lt; pow2(20))
        
            fprintf('         Buffer memory: %d kS\n', obj.DriverData.bufferMemory/pow2(10));
           
        else
            
            fprintf('         Buffer memory: %d MS\n', obj.DriverData.bufferMemory/pow2(20));
            
        end
        
        % Sampling rate information
        maxSamplingRate = obj.DriverData.maxSamplingRate;
        
        if(maxSamplingRate &gt; 0 &amp;&amp; maxSamplingRate &lt; 1e9)
            
            fprintf(' Maximum sampling rate: %d MS/s\n', maxSamplingRate/1e6);
            
        elseif(maxSamplingRate &gt;= 1e9)
           
            fprintf(' Maximum sampling rate: %d GS/s\n', maxSamplingRate/1e9);
            
        else
            
            % Do nothing
            
        end
        
        clear bandwidthHZ;
        clear maxSamplingRate;

        % Output the signal generator type
        sigGenType = 'None';
    
        switch (obj.DriverData.sigGenType)

            case PicoConstants.SIG_GEN_FUNCT_GEN

                sigGenType = 'Function Generator';

            case PicoConstants.SIG_GEN_AWG

                sigGenType = 'Arbitrary Waveform Generator';

            otherwise

                % Already set to none

        end
    
        fprintf(' Signal Generator Type: %s\n', sigGenType);

        fprintf('\n');

    elseif(connectStatus.openUnit == PicoStatus.PICO_NOT_FOUND)

        error('No unit found, please check connections.');

    else

        error('Status code: %d\n', connectStatus.openUnit);

    end</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>MCode</Type>
      <Code>function cleanup(obj)
% This function is called before the object is disconnected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT
    
    if(isfield(obj.DriverData,'unitHandle'))

        unitHandle = obj.DriverData.unitHandle;
    
        if (isempty(unitHandle)) 
            % If no unithandle, return without doing anything
            return;
        end

        if (~libisloaded('ps2000a') &amp;&amp; ~libisloaded('ps2000aWrap'))

            % If the drivers are no longer loaded, return without doing
            % anything
            return;

        end        

        % Disconnect Code:

        disconnectStatus = calllib('ps2000a', 'ps2000aCloseUnit', unitHandle);

        if (disconnectStatus == PicoStatus.PICO_OK)

            fprintf(['Connection to PicoScope %s with serial number %s ' ...
                'closed successfully.\n'], obj.InstrumentModel, obj.DriverData.unitSerial);

        elseif (disconnectStatus == PicoStatus.PICO_INVALID_HANDLE)
            
            % No device with the handle, so should be disconnected.
            return;
            
        else

            if (isfield(obj.DriverData, 'unitSerial'))
                
                error('Disconnect:ConnectionNotClosed',['Connection to PicoScope %s with serial ' ...
                    'number %s not closed. Status code %d\n'], ...
                obj.InstrumentModel, obj.DriverData.unitSerial, disconnectStatus);
            
            end

        end

        % Only unload libraries if there are no more connected
        % oscilloscopes
        
        % Find the first handle number for the platform
        firstHandle = 0;
        
        if (ispc())
            
            firstHandle = 16384; % Windows PC
            
        else 
           
            firstHandle = 1; % Mac OS X and Linux
            
        end
        
        % Test the connection to a range of handle values up to a maximum
        lastHandle = firstHandle + obj.DriverData.constants.PS2000A_MAX_UNITS - 1;
        
        % Create an array to store status values for ping tests.
        % On Windows PCs, the first handle is 16384 so this will need to be
        % accounted for.
        if (ispc())
            
            pingStatus = zeros(lastHandle, 1);
            
        else
            
            pingStatus = zeros(obj.DriverData.constants.PS2000A_MAX_UNITS, 1);
            
        end
        
        % Test the handle value ranges
        for h = firstHandle:lastHandle

            pingStatus(h, 1) = calllib('ps2000a', 'ps2000aPingUnit', h);
            
        end
        
        if (ispc())
                
            % Need to resize arrray as first handle is not 0
            pingStatus(1:firstHandle - 1) = [];
                
        end
        
        if (any(pingStatus == PicoStatus.PICO_OK))
         
          % Device still connected
          disp('Other PicoScope 2000 Series devices using the ps2000a shared library are still connected - libraries will not be unloaded.');
          
        else

            unloadlibrary('ps2000aWrap');
            unloadlibrary('ps2000a');
            
            if (~libisloaded('ps2000a') &amp;&amp; ~libisloaded('ps2000aWrap'))

                disp('Libraries unloaded successfully.');

            else

                error('Libraries not unloaded.');

            end

        end
        
    else
        
        warning('Disconnect:NoDevicesFound', 'Disconnect: No devices found.');
        
    end</Code>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>bandwidth</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
 
    propertyValue = obj.DriverData.bandwidth;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>bandwidth represents the maximum bandwidth (3dB cut-off point) of the oscilloscope in hertz.</Description>
            </Property>
            <Property>
               <Name>bufferMemory</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.bufferMemory;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Defines the size of the memory buffer on the device (in samples).</Description>
            </Property>
            <Property>
               <Name>channelCount</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.channelCount;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The number of analog input channels on the device.</Description>
            </Property>
            <Property>
               <Name>channelSettings</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
    
    propertyValue = obj.DriverData.channelSettings;
    </GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Object</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description>A matrix containing the channel settings for analog channels.

This will consist of a 2 x 4 or 4 x 4 matrix depending on the number of analog channels on the device.

The row number will correspond to the channel:

1 - Channel A
2 - Channel B
3 - Channel C
4 - Channel D

Each row will contain the following elements corresponding to:

enabled - set to 0 (off) or 1 (on).
dc - set AC (0)/DC (1) coupling. 
range - an enumeration representing the voltage range (PS2000A_RANGE).
analogueOffset - the offset on the channel.

</Description>
            </Property>
            <Property>
               <Name>digitalPortCount</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.digitalPortCount;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of digital ports on the device.

For non-MSO devices this will be set to 0.</Description>
            </Property>
            <Property>
               <Name>displayOutput</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.displayOutput;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.displayOutput = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Enumeration value to select whether to display output from function calls in the MATLAB Command Window.

Set to 1 to display output, 0 to hide output.

Note: Output will still be sent to the Command Window when calling the icdevice, connect and disconnect functions. Warning and error messages will still continue to be displayed from function calls.

</Description>
            </Property>
            <Property>
               <Name>firstRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.firstRange;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                     <Value>10.0</Value>
                     <Value>11.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Enumeration corresponding to the lowest voltage range supported by the device.</Description>
            </Property>
            <Property>
               <Name>hasHardwareEts</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.hasHardwareEts;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Indicates if the device has hardware-based Equivalent Time Sampling.</Description>
            </Property>
            <Property>
               <Name>lastRange</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.lastRange;
    </GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                     <Value>3.0</Value>
                     <Value>4.0</Value>
                     <Value>5.0</Value>
                     <Value>6.0</Value>
                     <Value>7.0</Value>
                     <Value>8.0</Value>
                     <Value>9.0</Value>
                     <Value>10.0</Value>
                     <Value>11.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>10</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Enumeration corresponding to highest voltage range supported by device.</Description>
            </Property>
            <Property>
               <Name>maxADCValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
    
    propertyValue = obj.DriverData.maxADCValue;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>32512</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The maximum ADC count value for the device.</Description>
            </Property>
            <Property>
               <Name>maxSamplingRate</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.maxSamplingRate;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The maximum single shot sampling rate for the device (samples per second).</Description>
            </Property>
            <Property>
               <Name>minADCValue</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.minADCValue;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>-32512</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The minimum ADC count value for the device.</Description>
            </Property>
            <Property>
               <Name>numPostTriggerSamples</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.numPostTriggerSamples;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.numPostTriggerSamples = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of samples to store after a trigger event.

Note: the maximum number of samples returned is always numPreTriggerSamples + numPostTriggerSamples. This is
true even if no trigger event has been set.

When used in Streaming mode, this is the maximum number of raw samples after a trigger event for each enabled channel.</Description>
            </Property>
            <Property>
               <Name>numPreTriggerSamples</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.numPreTriggerSamples;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.numPreTriggerSamples = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of samples to store before the trigger event.

When used in Streaming mode, this is the maximum number of raw samples before the trigger event for each enabled channel.
</Description>
            </Property>
            <Property>
               <Name>timebase</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.timebase;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    obj.DriverData.timebase = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>65</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The timebase used for the scope when capturing data in Block and Rapid Block mode - please refer to the timebases section in the Help Guide for the formulae to calculate the timebase index based on the interval.

The default value set is 65 corresponding to a sampling interval as follows:

500 MS/s maximum sampling rate models - 1008 ns
1 GS/s maximum sampling rate models - 504 ns
PicoScope 2205 MSO - 650 ns



 </Description>
            </Property>
            <Property>
               <Name>unitHandle</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.unitHandle;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The handle assigned by the underlying ps2000a/libps2000a shared library for the device.</Description>
            </Property>
            <Property>
               <Name>unitSerial</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    propertyValue = obj.DriverData.unitSerial;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>always</ReadOnly>
               <Description>The device batch/serial number.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>deviceReset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function deviceReset(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Show warning message
    warning('PS2000AInstrumentDriver:DeviceResetNotSupported', ...
        'devicereset is not supported by this Instrument Driver - please use the resetDevice function instead.');</MCode>
               </Code>
               <Description>The devicereset function is not supported by this Instrument Driver. Please use the resetDevice function instead.</Description>
            </Method>
            <Method>
               <Name>getUnitInfo</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, unitInfoValues] = getUnitInfo(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    unitHandle = obj.DriverData.unitHandle;
    
    unitInfoDesc = {'Driver version: '; 'USB version: '; 'Hardware version: '; 'Variant: '; ...
        'Batch &amp; Serial: '; 'Cal. Date: '; 'Kernel version: '; 'Digital HW version: '; ...
        'Analogue HW version: '; 'Firmware 1: '; 'Firmware 2: '};

    infoLine = blanks(40);

    unitInfoValues = cell(11,1);

	reqSize = length(infoLine);

    status = zeros(11,1,'uint32');

    % Loop through and put together information
    for n = 1:11

        [status(n,1), infoLine1, reqSize]  = calllib('ps2000a', ...
            'ps2000aGetUnitInfo', unitHandle, infoLine, ... 
            length(infoLine), reqSize,(n-1));
        
        if (status(n,1) ~= PicoStatus.PICO_OK)
           
            switch(status(n,1))
                    
                case PicoStatus.PICO_DRIVER_FUNCTION
                    
                    error('getUnitInfo: Another driver function is being processed.');
                
                otherwise
                    
                    error('getUnitInfo: Status code %d - please refer to the PicoStatus.m file.', status); 
                
            end
            
        
        end

        unitInfoLine = strcat(unitInfoDesc(n), infoLine1);
        unitInfoValues(n) = cellstr(unitInfoLine);
        
    end</MCode>
               </Code>
               <Description>getUnitInfo(obj) retrieves information about the specified device for the following types of information:

1.   Driver version
2.   USB version
3.   Hardware version
4.   Variant number
5.   Batch &amp; Serial number
6.   Calibration date
7.   Kernel Version
8.   Digital Hardware version
9.   Analogue Hardware version
10.  Firmware 1
11.  Firmware 2

Input Arguments:

obj - the object representing the device.

Output Arguments:

status - an array containing the status codes returned by the driver on each call to the underlying ps2000aGetUnitInfo function.
unitInfoValues - a cell array containing strings providing information on the device connected to.

For further information on the underlying ps2000aGetUnitInfo function please refer to the PicoScope 2000 Series (A API) PC Oscilloscopes and MSOs Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>ps2000aFlashLed</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000aFlashLed(obj, start)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps2000a', 'ps2000aFlashLed', ...
        obj.DriverData.unitHandle, start);
            
	if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aFlashLed:- status code: %d - please refer to the PicoStatus.m file.', ...
            status);
        
    end</MCode>
               </Code>
               <Description>ps2000aFlashLed(obj, start) flashes the LED on the front of the scope without blocking the calling thread.

Calls to ps2000aRunStreaming, ps2000aRunBlock and runBlock cancel any flashing started by this function. It is not possible to set the LED to be constantly illuminated, as this state is used to indicate that the scope has not been initialized.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the device.
start - the action required:

	&lt; 0 : flash the LED indefinitely.
	0 : stop the LED flashing.
	&gt; 0 : flash the LED start times.

Output Arguments:

status - status code returned by the driver.
</Description>
            </Method>
            <Method>
               <Name>ps2000aGetAnalogueOffset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maximumVoltage, minimumVoltage] = ps2000aGetAnalogueOffset(obj, range, coupling)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Values to be used for pointers
    maxVoltage = 0.0;    
    minVoltage = 0.0;

    [status, maximumVoltage, minimumVoltage] = calllib('ps2000a', ...
        'ps2000aGetAnalogueOffset', obj.DriverData.unitHandle, ...
        range, coupling, maxVoltage, minVoltage);
    
    clear maxVoltage;
    clear minVoltage;
    
    if (status ~= PicoStatus.PICO_OK)
       
        error('ps2000aGetAnalogueOffset:- status code: %d - please refer to the PicoStatus.m file.', status);
    
    end</MCode>
               </Code>
               <Description>ps2000aGetAnalogueOffset(obj, range, coupling) is used to get the maximum and minimum allowable analog offset for a specific voltage range.

This function applies to all PicoScope 2000 Series units supported by this Instrument Driver except the PicoScope 2205 MSO.

This function may be used with the Test and Measurement Tool.

Input Arguments: 

obj - the object representing the device.
range - an enPS2000ARange enumeration representing the voltage range to be used.
coupling - an enPS2000ACoupling enumeration representing the the type of AC/DC coupling used.

Output Arguments:

status - status code returned by the driver.
maximumVoltage - the maximum voltage allowed for the range. If device does not support analog offset, zero will be returned.
minimumVoltage - the minimum voltage allowed for the range. If device does not support analog offset, zero will be returned.

For further information on the ps2000aGetAnalogueOffset function please refer to the PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.


</Description>
            </Method>
            <Method>
               <Name>ps2000aGetChannelInformation</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, ranges, length] = ps2000aGetChannelInformation(obj, channels)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Current info supported is PS2000A_CI_RANGES
    info = obj.DriverData.enums.enPS2000AChannelInfo.PS2000A_CI_RANGES;
    probe = 0;
    ranges = zeros(10, 1);
    length = 0;

    [status, ranges, length] = calllib('ps2000a', ...
        'ps2000aGetChannelInformation', obj.DriverData.unitHandle, info, ...
        0, ranges, length, channels);
    
    
    clear info;
    clear probe;
    
    if (status ~= PicoStatus.PICO_OK)
           
       error('ps2000aGetChannelInformation:- status code: %d - please refer to the PicoStatus.m file.', status);
        
    end   </MCode>
               </Code>
               <Description>ps2000aGetChannelInformation(obj, channels) queries which extra voltage ranges are available on a scope device.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the device.
channels - the channel for which the range information is required (an enPS2000AChannel enumeration value).

Output arguments:

status - status code returned by the driver.
ranges - an array that will be populated with available enPS2000ARange enumeration values.
length - the number of elements written to the ranges array.

Note that the enumerations start from 0 and should be offset by +1 to be used with the SCOPE_INPUT_RANGES array in the PicoConstants class.</Description>
            </Method>
            <Method>
               <Name>ps2000aGetMaxDownSampleRatio</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maxDownSampleRatio] = ps2000aGetMaxDownSampleRatio(obj, numUnaggregatedSamples, downSampleRatioMode, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Value to which the max downsample ration is assigned
    maxDownSampleRatio = 0;        

    [status, maxDownSampleRatio] = calllib('ps2000a', ...
        'ps2000aGetMaxDownSampleRatio', obj.DriverData.unitHandle, ...
            numUnaggregatedSamples, maxDownSampleRatio, downSampleRatioMode, segmentIndex);
        
    if (status ~= PicoStatus.PICO_OK)
           
       error('ps2000aGetMaxDownSampleRatio:- status code %d - please refer to the PicoStatus.m file.', status);
        
    end   </MCode>
               </Code>
               <Description>ps2000aGetMaxDownSampleRatio(obj, numUnaggregatedSamples, downSampleRatioMode, segmentIndex) returns the maximum downsampling ratio that can be used for a given number of samples in a given downsampling mode.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the device.
numUnaggregatedSamples - the number of unprocessed samples to be downsampled.
downSampleRatioMode - the downsampling mode (an enPS2000ARatioMode enumeration value).
segmentIndex - the memory segment where the data is stored.

Output Arguments:

status - status code returned by the driver.
maxDownSampleRatio - the maximum possible downsampling ratio.</Description>
            </Method>
            <Method>
               <Name>ps2000aGetMaxSegments</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, maxSegments] = ps2000aGetMaxSegments(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    % Passing pointer to function
    maxSegments = 0; 

    [status, maxSegments] = calllib('ps2000a', 'ps2000aGetMaxSegments', ...
                                obj.DriverData.unitHandle, maxSegments);
                            
	if (status ~= PicoStatus.PICO_OK)
           
		error('ps2000aGetMaxSegments:- status code %d - please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps2000aGetMaxSegments(obj) returns the maximum number of segments allowed for the opened device. 

Refer to ps2000aMemorySegments for specific figures.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the device.

Output Arguments:

status - status code returned by the driver.
maxSegments - the maximum number of segments allowed.
</Description>
            </Method>
            <Method>
               <Name>ps2000aGetTimebase2</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIntervalNanoSeconds, maxSamples] = ps2000aGetTimebase2(obj, timebase, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    timeIntervalNanoSeconds = 0;
    oversample = 1;
    
    numSamples = obj.DriverData.numPreTriggerSamples + ...
        obj.DriverData.numPostTriggerSamples;
    
    maxSamples = 0; % Pass data to return the max samples from the driver
    
    [status, timeIntervalNanoSeconds, maxSamples] = calllib('ps2000a', ...
        'ps2000aGetTimebase2', obj.DriverData.unitHandle, timebase, numSamples, ...
        timeIntervalNanoSeconds, oversample, maxSamples, segmentIndex);
    
    if (status ~= PicoStatus.PICO_OK)
           
        % Inform the User that an invalid timebase index has been selected
        if (status == PicoStatus.PICO_INVALID_TIMEBASE)
           
            warning('PS2000AInstrumentDriver:InvalidTimebase', ['Invalid timebase ', ...
                'index used in call to ps2000aGetTimebase2().']);
            
        else
            
            error('PS2000AInstrumentDriver:GetTimebase2', ['ps2000aGetTimebase2:- Status code: ', ...
                '%d. Please refer to the PicoStatus.m file.'], status);
        
        end
        
    end
    
    clear numSamples;</MCode>
               </Code>
               <Description>ps2000aGetTimebase2(obj, timebase, segmentIndex) discovers which timebases are available on the oscilloscope, returning the time interval as a floating point value.

The channels (and digital ports for MSO devices) should be setup using the ps2000aSetChannel function first.

This function calculates the sampling rate and maximum number of samples for a given timebase under the specified conditions. The result will depend on the number of channels enabled by the last call to |ps2000aSetChannel|. 

To use ps2000aGetTimebase2, first estimate the timebase number that you require using the information in the
Timebases guide (see below). Next, call one of these functions with the timebase that you have just chosen and verify that the
timeIntervalNanoseconds argument that the function returns is the value that you require. You may need to iterate this process until you obtain the time interval that you need.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the device.
timebase: a timebase index.
segmentIndex: the index of the memory segment to use.

Output parameters:

status - status code returned by the driver.
timeIntervalNanoSeconds: the time interval between readings at the selected timebase.
maxSamples: the maximum number of samples available. 

For further information on the ps2000aGetTimebase2 function please refer to the  PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.</Description>
            </Method>
            <Method>
               <Name>ps2000aMemorySegments</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nMaxSamples] = ps2000aMemorySegments(obj, nSegments)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    nMaxSamples = 0; % Initialise value for pointer

    [status, nMaxSamples] = calllib('ps2000a', 'ps2000aMemorySegments', ...
        obj.DriverData.unitHandle, nSegments, nMaxSamples);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aMemorySegments:- status code %d - please refer to the PicoStatus.m file.', status);  
        
    end</MCode>
               </Code>
               <Description>ps2000aMemorySegments(obj, nSegments) sets the number of memory segments that the scope will use.

When the scope is opened, the number of segments defaults to 1, meaning that each capture fills the scope's available memory. This function allows you to divide the memory into a number of segments so that the scope can store several waveforms sequentially. 

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the device.
nSegments - the number of segments required from 1 to the number of maximum segments returned by ps2000aGetMaxSegments.

Output Arguments:

status - status code returned by the driver.
nMaxSamples - the number of samples available in each segment. This is the total number over all channels, so if more than
one channel is in use then the number of samples available to each channel is nMaxSamples divided by 2 if 2 channels are enabled or 4 if 3 or 4 channels are enabled.</Description>
            </Method>
            <Method>
               <Name>ps2000aPingUnit</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000aPingUnit(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    status = calllib('ps2000a', 'ps2000aPingUnit ', obj.DriverData.unitHandle);
    </MCode>
               </Code>
               <Description>ps2000aPingUnit(obj) can be used to check that the already opened device is stil connected to the USB port and communication is successful.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the device.

Output Arguments:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>ps2000aSetChannel</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000aSetChannel(obj, channel, enabled, type, range, analogueOffset)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    status = calllib('ps2000a', 'ps2000aSetChannel', ...
        obj.DriverData.unitHandle, channel, enabled, type, ...
        range, analogueOffset);
    
    % Obtain channel settings information 
    chSettings = obj.DriverData.channelSettings;
    
    % Only process if status is ok.
	if (status == PicoStatus.PICO_OK)
        
        switch(channel)
            
            case obj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_A
                
                chSettings(1,1) = enabled;
                chSettings(1,2) = type;
                chSettings(1,3) = range;
                chSettings(1,4) = analogueOffset; 
                
            case obj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_B
                
                chSettings(2,1) = enabled;
                chSettings(2,2) = type;
                chSettings(2,3) = range;
                chSettings(2,4) = analogueOffset; 

            case obj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_C
                
                chSettings(3,1) = enabled;
                chSettings(3,2) = type;
                chSettings(3,3) = range;
                chSettings(3,4) = analogueOffset;  
                
            case obj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_D
                
                chSettings(4,1) = enabled;
                chSettings(4,2) = type;
                chSettings(4,3) = range;
                chSettings(4,4) = analogueOffset; 
                
            otherwise
                
                % Do nothing
                    
        end
        
        obj.DriverData.channelSettings = chSettings;
        
        % Information to be passed to the wrapper dll
        enabledChannels = zeros(PicoConstants.QUAD_SCOPE, 1, 'int16');
        
        switch(obj.DriverData.channelCount)
            
            case PicoConstants.DUAL_SCOPE
           
                % Only channels A and B
                enabledChannels = [chSettings(1,1); ...
                    chSettings(2,1); 0; 0];
            
            case PicoConstants.QUAD_SCOPE
                
                enabledChannels = [chSettings(1,1); ...
                    chSettings(2,1); ...
                    chSettings(3,1); ...
                    chSettings(4,1)];
            
            otherwise
        
                % Do nothing
            
        end
        
        setEnabledChannelsStatus = calllib('ps2000aWrap', ...
                    'setEnabledChannels', obj.DriverData.unitHandle, ...
                    enabledChannels);
        
    else
        
        error('ps2000aSetChannel:- status code: %d - please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps2000aSetChannel(obj, channel, enabled, type, range, analogueOffset) specifies whether an input channel is to be enabled, its input coupling type, voltage range, and analog offset.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the device.
channel - the channel to be configured (an enumeration from the enPS2000AChannel range - PS2000A_CHANNEL_A to PS2000A_CHANNEL_B or PS2000A_CHANNEL_D depending on the number of analog channels).
enabled - set to TRUE (1) to enable the channel, FALSE (0) otherwise.
type - the impedance and coupling type (an enumeration from the enPS2000ACoupling range).
range - the input voltage range (an enumeration from the enPS2000ARange set of values).
analogueOffset - a voltage to add to the input channel before digitization.

Output Arguments:

status - status code returned by the driver.

For further information on the ps2000aSetChannel function, please refer to the PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.

</Description>
            </Method>
            <Method>
               <Name>ps2000aSetDataBuffer</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000aSetDataBuffer(obj, channel, pBuffer, bufferLth, segmentIndex, mode)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    status = calllib('ps2000a', 'ps2000aSetDataBuffer', ...
        obj.DriverData.unitHandle, channel, pBuffer, bufferLth, ...
        segmentIndex, mode);
            
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aSetDataBuffer:- status code %d', status);
        
    end</MCode>
               </Code>
               <Description>ps2000aSetDataBuffer(obj, channel, buffer, bufferLth, segmentIndex, mode) tells the driver where to store the data, either unprocessed or downsampled, that will be returned after the next call to one of the GetValues functions.

Input Arguments:

obj - the object representing the device.
channel - the channel to which the buffer corresponds (use one of the values from the enPS2000AChannel range (PS2000A_CHANNEL_A to PS2000A_CHANNEL_D) for analog channels). 
To set the buffer for a digital port (MSO models only), use one of these values: PS2000A_DIGITAL_PORT0 = hex2dec('80') or
 PS2000A_DIGITAL_PORT1 = hex2dec('81')
pBuffer - a libpointer to a 1-D array to receive the data values for the channel.
bufferLth - the length of the buffer array.
segmentIndex - the number of the memory segment to be used.
mode - the downsampling mode (see ps2000aGetValues for the available modes).

Output Arguments:

status - status code returned by the device.

If capturing data in streaming mode without aggregation, the buffer must also be passed as the driverBuffer argument for the setAppAndDriverBuffers function call.

For further information on the ps2000aSetDataBuffer function please refer to the PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.
</Description>
            </Method>
            <Method>
               <Name>ps2000aSetDataBuffers</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000aSetDataBuffers(obj, channel, pBufferMax, pBufferMin, bufferLth, segmentIndex, ratioMode)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    status = calllib('ps2000a', 'ps2000aSetDataBuffers', ...
        obj.DriverData.unitHandle, channel, pBufferMax, pBufferMin, ...
        bufferLth, segmentIndex, ratioMode);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aSetDataBuffers:- status code %d - please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps2000aSetDataBuffers(obj, channel, pBufferMax, pBufferMin, bufferLth, segmentIndex, ratioMode) tells the driver the location of one or two buffers for receiving data. You need to allocate memory for the buffers before calling this function. If you do not need
two buffers, because you are not using aggregate mode, you can optionally use ps2000aSetDataBuffer instead.

If aggregate mode is not being used, then ps2000aSetDataBuffer can optionally be used instead.

Input Arguments:

obj - the object representing the device.
channel -  the channel for which to set the buffers (an enumeration from the PS2000A_CHANNEL range).
pBufferMax - a libpointer to a 1-D array to receive the maximum data values in aggregation mode, or the non-aggregated values otherwise.
pBufferMin -  a libpointer to a 1-D array to receive the minimum aggregated data values. Not used in other downsampling modes if the maximum buffer has been defined.
bufferLth - the size of the arrays referenced by pBufferMax and pBufferMin.
segmentIndex - the number of the memory segment to be used.
mode - the downsampling mode (see ps2000aGetValues for the available modes).

Output Arguments:

status - status code returned by the device.

If capturing data in streaming mode with aggregation, pBufferMax and pBufferMin must also be passed as the driverMaxBuffer and driverMinBuffer arguments respectively for the setMaxMinAppAndDriverBuffers function call.

For further information on the ps2000aSetDataBuffer function please refer to the PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.</Description>
            </Method>
            <Method>
               <Name>ps2000aStop</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000aStop(obj)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    status = calllib('ps2000a', 'ps2000aStop', obj.DriverData.unitHandle);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aStop:- status code %d - please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps2000aStop(obj) stops the scope device from sampling data.

The function is mainly used in streaming mode to stop a streaming capture. It can
optionally be used in block mode to stop a capture early, either before or after
triggering; and in rapid block mode to stop a sequence of captures. If a block mode
capture is interrupted, ps2000aGetValues will indicate that no samples are available
and the buffer will contain no data. 

Always call this function after the end of a capture to ensure that the scope is ready
for the next capture. 

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the device.

Output Arguments:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>resetDevice</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function resetDevice(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
       
    % Set analogue channels defaults
    setChannelStatus = invoke(obj, 'setChannelDefaults');

    % Obtain Digital group object
    digitalGroupObj = get(obj, 'Digital');
    digitalGroupObj = digitalGroupObj(1);

    % Set digital port defaults if device has digital channels

    if (obj.DriverData.digitalPortCount &gt; 0)

        setDigitalPortStatus = invoke(digitalGroupObj, 'setDigitalPortDefaults');

    end

    %%%%%%%

    % Turn off ETS

    disp('Turning off Equivalent Time Sampling...');

    % Obtain Block group object
    blockGroupObj = get(obj, 'Block');
    blockGroupObj = blockGroupObj(1);

    [etsStatus, samplingTimePs] = invoke(blockGroupObj, 'ps2000aSetEts', ...
        obj.DriverData.enums.enPS2000AEtsMode.PS2000A_ETS_OFF, 0, 0);

    % Turn off trigger

    fprintf('Turning off trigger...\n\n');

    % Obtain Trigger group object

    triggerGroupObj = get(obj, 'Trigger');
    triggerGroupObj = triggerGroupObj(1);
    
    obj.DriverData.autoTriggerMs = 0;
    obj.DriverData.delay = 0;

    triggerStatus = invoke(triggerGroupObj, 'setTriggerOff');

    fprintf('Default Block mode parameters:-\n\n');

    % Set the default number of pre-trigger and post-trigger samples
    obj.DriverData.numPreTriggerSamples = 0;
    obj.DriverData.numPostTriggerSamples = 8192;
    
    totalSamples = obj.DriverData.numPreTriggerSamples + obj.DriverData.numPostTriggerSamples;

    % Set the timebase - default of 64 corresponds to following sampling intervals:
    %   500 MS/s max. sampling rate models - 992 ns
    %   2205 MSO - 640ns
    %   1 GS/s  - max. sampling rate models 496 ns

    obj.DriverData.timebase = 64;
    timeIntervalNs = 0;
    segmentIndex = 0;

    % Call ps2000aGetTimebase2 to return interval in ns

    [timebaseStatus, timeIntervalNs, maxBlockSamples] = ...
        invoke(obj, 'ps2000aGetTimebase2', obj.DriverData.timebase, segmentIndex);

    fprintf('               Timebase index : %d\n', obj.DriverData.timebase);
    fprintf('                 Time Interval: %.1f ns\n', timeIntervalNs);
    fprintf(' Number of pre-trigger samples: %d\n', obj.DriverData.numPreTriggerSamples);
    fprintf('Number of post-trigger samples: %d\n', obj.DriverData.numPostTriggerSamples);
    fprintf('       Total number of samples: %d\n', totalSamples);

    fprintf('\n');

    fprintf('Default Streaming mode parameters:-\n\n');

    obj.DriverData.streamingInterval = 1e-6; % 1us -&gt; 1MS/s
    obj.DriverData.autoStop = PicoConstants.TRUE;

    fprintf(' Streaming interval: %1.2d s\n', obj.DriverData.streamingInterval);
    fprintf('Streaming auto stop: %d\n', obj.DriverData.autoStop);

    fprintf('\n');

    if(obj.DriverData.sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN || ...
            obj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)

        fprintf('Default Signal generator parameters:-\n\n');

        obj.DriverData.startFrequency = 1000;
        obj.DriverData.stopFrequency = 1000;
        obj.DriverData.offsetVoltage = 0;
        obj.DriverData.peakToPeakVoltage = 2000;

        fprintf('      Start frequency: %d Hz\n', obj.DriverData.startFrequency);
        fprintf('       Stop frequency: %d Hz\n', obj.DriverData.stopFrequency);
        fprintf('       Offset voltage: %d mV\n', obj.DriverData.offsetVoltage);
        fprintf(' Peak to Peak voltage: %d mV\n', obj.DriverData.peakToPeakVoltage);

    end

    fprintf('\n');</MCode>
               </Code>
               <Description>resetDevice(obj) sets the default parameters for the device.

This includes the following:

1. Device specific properties.
1. Enabling all available channels to +/- 5 V range, DC coupled with 0 volt analog offset.
2. Turning off the trigger (autoTriggerMs = 0 &amp; delay = 0.0).
3. Block mode parameters:

	Timebase index - 64 
	numPreTriggerSamples - 0
 	numPostTriggerSamples - 1000000

4. Streaming mode parameters:

	streamingInterval - 1e-6 (seconds)
	autoStop - 1
    
5. Signal Generator parameters:
        
	offsetVoltage - 0mV
	peakToPeakVoltage - 2000mV
	startFrequency - 1000 (Hz)
	stopFrequency - 1000 (Hz)

Input Arguments:

obj - the object representing the device.

Output Arguments:

None.


</Description>
            </Method>
            <Method>
               <Name>setChannelDefaults</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status] = setChannelDefaults(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    if (obj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('Default Analog Channel Setup:-\n');
        fprintf('------------------------------\n\n');
        
    end

    chA = obj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_A;
    chB = obj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_B;
    chC = obj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_C;
    chD = obj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_D;

    % Assign values used repeatedly to local variables

    true  = PicoConstants.TRUE;
    false = PicoConstants.FALSE;
    range5V = obj.DriverData.enums.enPS2000ARange.PS2000A_5V;
    analogueOffset = 0.0;
    
    % Matrix of values to represent channels (rows) x properties (cols)
    obj.DriverData.channelSettings = zeros(obj.DriverData.channelCount, 4);

    % Set Channels A through D, updating internal settings
    % Parameters are channel index, enabled, dc coupling, range index and 
    % analogue offset.
    % If a device has only 2 analogue channels, only the settings for these
    % will be sent to the underlying driver.

    % Update internal settings
    
    % Create a num channels x fields array
    chSettings = zeros(obj.DriverData.channelCount, 4);
    
    for ch = 1:obj.DriverData.channelCount
        
        channelSettings(ch).enabled = true;
        channelSettings(ch).dc = true;
        channelSettings(ch).range = range5V;
        channelSettings(ch).offset = analogueOffset;
        
        % Transpose the resulting array for the channel and combine
        chSettings(ch, :) = cell2mat(struct2cell(channelSettings(ch)))';

    end
    
    % Assign resulting matrix to object's DriverData.channelSettings
    % property
    obj.DriverData.channelSettings = chSettings;
    
    status = zeros(obj.DriverData.channelCount, 1);
    
    status(1) = invoke(obj, 'ps2000aSetChannel', chA, true, true, range5V, analogueOffset);
    
    if (obj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('Channel A:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: +/- 5 V\n\tAnalog Offset: 0.0 V\n\n');
        
    end
    
    status(2) = invoke(obj, 'ps2000aSetChannel', chB, true, true, range5V, analogueOffset);
        
    if (obj.DriverData.displayOutput == PicoConstants.TRUE)
    
        fprintf('Channel B:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: +/- 5 V\n\tAnalog Offset: 0.0 V\n\n');
        
    end
    
    if(obj.DriverData.channelCount == PicoConstants.QUAD_SCOPE)
        
        status(3) = invoke(obj, 'ps2000aSetChannel', chC, true, true, range5V, analogueOffset);
        
        if (obj.DriverData.displayOutput == PicoConstants.TRUE)
        
            fprintf('Channel C:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: +/- 5 V\n\tAnalog Offset: 0.0 V\n\n');
            
        end
        
        status(4) = invoke(obj, 'ps2000aSetChannel', chD, true, true, range5V, analogueOffset);
        
        if (obj.DriverData.displayOutput == PicoConstants.TRUE)
        
            fprintf('Channel D:-\n\tEnabled: True\n\tCoupling: DC\n\tRange: +/- 5 V\n\tAnalog Offset: 0.0 V\n\n');
            
        end
    
    end
        
    % Clear local variables
    clear chA;
    clear chB;
    clear chC;
    clear chD;
    
    clear true;
    clear range5V;
        </MCode>
               </Code>
               <Description>setChannelDefaults(obj) sets the following default values for any analog channels found on the device:

Analog Channel:

Enabled                : True
Coupling              : DC
Voltage Range     : 5 V
Analog Offset  : 0.0 V

Input Arguments:

obj - the object representing the device.

Output Arguments:

None.

</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>block</Name>
         <Description>The Block group contains a set of properties and functions related to the block mode capture functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="block" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>maxEtsCycles</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.maxEtsCycles;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>maxEtsInterleave</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
	propertyValue = deviceObj.DriverData.maxEtsInterleave;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>getBlockData</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, overflow, channelA, channelB, channelC, channelD, dPort0, dPort1] = getBlockData(obj, startIndex, segmentIndex, ratio, ratioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Check ratio mode is not aggregated
    if (ratioMode ~= deviceObj.DriverData.enums.enPS2000ARatioMode.PS2000A_RATIO_MODE_AGGREGATE)

        unitHandle = deviceObj.DriverData.unitHandle;

        channelCount = deviceObj.DriverData.channelCount;

        portCount = deviceObj.DriverData.digitalPortCount;

        % Retrieve channel settings - channel x data field matrix
        channelSettings = deviceObj.DriverData.channelSettings;

        % Retrieve port settings - port x data field matrix
        portSettings = deviceObj.DriverData.digitalPortSettings;

        % Create empty arrays for channel data.
        channelA = [];
        channelB = [];
        channelC = [];
        channelD = [];

        dPort0 = [];
        dPort1 = [];

        % Overflow indicator
        overflow = 0;

        % Initialise variable for array of libpointers for analogue
        % channels
        pABuffer = libpointer;

        % Initialise status
        setBufferStatus = 0;

        % Total number of samples to set for data buffers, taking into
        % account the downsampling ratio 
        totalSamples = ceil((deviceObj.DriverData.numPreTriggerSamples + ...
            deviceObj.DriverData.numPostTriggerSamples)/ratio);

        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('getBlockData: Setting up data buffers...\n');
            
        end

        for ch = 1:channelCount

            % Set Data Buffer if channel is enabled - index 1 indicates if
            % channel is enabled
            if (channelSettings(ch,1) == PicoConstants.TRUE)

                % Store array of libpointers
                pABuffer(ch) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));

                setBufferStatus = calllib('ps2000a', 'ps2000aSetDataBuffer', ...
                    unitHandle, (ch - 1), pABuffer(ch), totalSamples, ...
                    segmentIndex, ratioMode);

                if (setBufferStatus ~= PicoStatus.PICO_OK)

                    error('getBlockData:- Set Data Buffer for Channel %d status code: %d', ...
                        (ch - 1), setBufferStatus);

                end

            end

        end

        % Initialise variable for array of libpointers for digital
        % channels
        pDBuffer = libpointer;

        for port = 1:portCount

            % Set Data Buffer if channel is enabled - index 1 indicates if
            % channel is enabled
            if (portSettings(port,1) == PicoConstants.TRUE)

                % Store array of libpointers
                pDBuffer(port) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));

                setBufferStatus = calllib('ps2000a', 'ps2000aSetDataBuffer', ...
                    unitHandle, (port - 1 + deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT0), ... 'PORT0 = 128, PORT1 = 129
                    pDBuffer(port), totalSamples, segmentIndex, ratioMode);

                if (setBufferStatus ~= PicoStatus.PICO_OK)

                    error('getDigitalBlockData:- Set Data Buffer for Digital Port %d status code: %d', ...
                        (port - 1), setBufferStatus);

                end

            end

        end

        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('getBlockData: Retrieving data...\n');
            
        end

        % Call ps2000aGetValues
        [getValuesStatus, numSamples, overflow] = ...
            calllib('ps2000a', 'ps2000aGetValues', unitHandle, startIndex, ...
            totalSamples, ratio, ratioMode, segmentIndex, overflow);

        if (getValuesStatus == PicoStatus.PICO_OK)

            if (portCount &gt; 0 &amp;&amp; deviceObj.DriverData.displayOutput == PicoConstants.TRUE)

                fprintf('getBlockData: Assigning digital data to port array.\n');

            end

            for port = 1:portCount

                if (portSettings(port,1) == PicoConstants.TRUE)

                    switch (port - 1 + deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT0)

                        case deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT0

                            dPort0 = pDBuffer(port).Value;

                        case deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT1

                            dPort1 = pDBuffer(port).Value;

                        otherwise

                            % Do nothing

                    end

                end

            end

            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getBlockData: Assigning analog data to array and converting to millivolts.\n');
                
            end

            % Obtain max ADC count value
            maxADCValue = double(deviceObj.DriverData.maxADCValue);

            % Retrieve data values for enabled channels
            for ch = 1:channelCount

                if (channelSettings(ch,1) == PicoConstants.TRUE)

                    % Obtain the index for the
                    % PicoConstants.SCOPE_INPUT_RANGES array corresponding
                    % to the voltage range selected for the channel.
                    scopeInputIndex = channelSettings(ch,3) + 1;

                    % Obtain the voltage range for the channel.
                    voltageRange = PicoConstants.SCOPE_INPUT_RANGES(scopeInputIndex);

                    bufferValues = adc2mv(pABuffer(ch).Value, voltageRange, ...
                        maxADCValue);

                    switch (ch - 1)

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_A

                            channelA = bufferValues;

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_B

                            channelB = bufferValues;

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_C

                            channelC = bufferValues;

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_D

                            channelD = bufferValues;

                        otherwise

                            % Do nothing

                    end

                end

            end

            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getBlockData: Data succesfully retrieved.\n');
                
            end

        else

            error('getBlockData:- status code: %d. Please refer to the PicoStatus.m file.', getValuesStatus);

        end


    else

        error('getBlockData: Aggregate Mode data collection not supported by this function.');

    end
</MCode>
               </Code>
               <Description>getBlockData(obj, startIndex, segmentIndex, ratio, ratioMode) returns block mode data with or without downsampling starting at the specified sample number.

Memory for the data arrays is allocated and the driver is informed where to store the data prior to retrieval. Data collection in Aggregation mode or with more than one downsampling mode is NOT supported by this function.

Channels not enabled or not supported by the device (e.g. channels C and D for a 2-channel oscilloscope) will be returned as an empty array.

This function can be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Block group.
startIndex - a zero-based index that indicates the start point for data collection. Use zero to start at the first sample.
segmentIndex - the number of the memory segment to be used/where the data is stored. Use 0 if the memory has not been segmented.
ratio - the downsampling factor that will be applied to the raw data.
ratioMode - which downsampling mode to use (specified by an enumeration from the enPS2000aRatioMode range of enumerations excluding PS2000A_RATIO_MODE_AGGREGATE).


Output Arguments:

status - status code returned by the driver.
numSamples - the number of samples retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.
channelA - an array containing data values (in millivolts) for channel A.
channelB - an array containing data values (in millivolts) for channel B.
channelC - an array containing data values (in millivolts) for channel C.
channelD - an array containing data values (in millivolts) for channel D.
portD0 - an array containing data values in binary format for digital Port 0 (in MSB order)
portD1 - an array containing data values in binary format for digital Port 1 (in MSB order)

Please also refer to the ps2000aSetDataBuffer, and ps2000aGetValues functions in the PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.
</Description>
            </Method>
            <Method>
               <Name>getEtsBlockData</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, overflow, etsTimes, channelA, channelB, channelC, channelD] = getEtsBlockData(obj, startIndex, segmentIndex, ratio, ratioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Check ratio mode is not aggregated
    if (ratioMode ~= deviceObj.DriverData.enums.enPS2000ARatioMode.PS2000A_RATIO_MODE_AGGREGATE')

        unitHandle = deviceObj.DriverData.unitHandle;

        channelCount = deviceObj.DriverData.channelCount;    

        % Retrieve channel settings - channel x data field matrix
        channelSettings = deviceObj.DriverData.channelSettings;

        % Create empty arrays for channel data.
        channelA = [];
        channelB = [];
        channelC = [];
        channelD = [];

        % Overflow indicator
        overflow = 0;

        % Initialise variable for array of libpointers for analogue
        % channels
        pBuffer = libpointer;

        % Initialise status
        setBufferStatus = 0;

        % Total number of samples to set for data buffers, taking into
        % account the downsampling ratio 
        totalSamples = ceil((deviceObj.DriverData.numPreTriggerSamples + ...
            deviceObj.DriverData.numPostTriggerSamples)/ratio);

        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('getEtsBlockData: Setting up data buffers...\n');
            
        end

        for ch = 1:channelCount

            % Set Data Buffer if channel is enabled - index 1 indicates if
            % channel is enabled
            if (channelSettings(ch,1) == PicoConstants.TRUE)

                % Store array of libpointers
                pBuffer(ch) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));

                setBufferStatus = calllib('ps2000a', 'ps2000aSetDataBuffer', ...
                    unitHandle, (ch - 1), pBuffer(ch), totalSamples, ...
                    segmentIndex, ratioMode);

                if (setBufferStatus ~= PicoStatus.PICO_OK)

                    error('getEtsBlockData:- Set Data Buffer for channel %d status code: %d', ...
                        (ch - 1), setBufferStatus);

                end

            end

        end

        % Set ETS Time buffer
        pEtsTimeBuffer = libpointer('int64Ptr', zeros(totalSamples, 1, 'int64'));

        status = calllib('ps2000a', 'ps2000aSetEtsTimeBuffer', ...
                    unitHandle, pEtsTimeBuffer, totalSamples);

        if (status ~= PicoStatus.PICO_OK)
           
            error('getEtsBlockData:- ps2000aSetEtsTimeBuffer returned status code: %d. Please refer to the PicoStatus.m file.', status);
            
        end
                
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('getEtsBlockData: Retrieving data...\n');
            
        end

        % Call ps2000aGetValues
        [getValuesStatus, numSamples, overflow] = calllib('ps2000a', 'ps2000aGetValues', ...
            unitHandle, startIndex, totalSamples, ratio, ratioMode, segmentIndex, overflow);

        if (getValuesStatus == PicoStatus.PICO_OK)
            
            % Retrieve ETS times
            etsTimes = pEtsTimeBuffer.Value;

            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getEtsBlockData: Assigning Analog data to array and converting to millivolts.\n');
                
            end

            % Obtain max ADC count value
            maxADCValue = double(deviceObj.DriverData.maxADCValue);

            % Retrieve data values for enabled channels
            for ch = 1:channelCount

                if (channelSettings(ch,1) == PicoConstants.TRUE)

                    % Obtain the index for the
                    % PicoConstants.SCOPE_INPUT_RANGES array corresponding
                    % to the voltage range selected for the channel.
                    scopeInputIndex = channelSettings(ch,3) + 1;

                    % Obtain the voltage range for the channel.
                    voltageRange = PicoConstants.SCOPE_INPUT_RANGES(scopeInputIndex);

                    bufferValues = adc2mv(pBuffer(ch).Value, voltageRange, ...
                        maxADCValue);

                    switch (ch - 1)

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_A

                            channelA = bufferValues;

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_B

                            channelB = bufferValues;

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_C

                            channelC = bufferValues;

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_D

                            channelD = bufferValues;

                        otherwise

                            % Do nothing

                    end

                end

            end

            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getEtsBlockData: Data succesfully retrieved.\n');
                
            end

        else

            error('getEtsBlockData:- ps2000aGetValues returned status code: %d. Please refer to the PicoStatus.m file.', getValuesStatus);

        end


    else

        error('getEtsBlockData: Aggregate Mode data collection not supported by this function.');

    end

</MCode>
               </Code>
               <Description>getEtsBlockData(obj, startIndex, segmentIndex, ratio, ratioMode) returns Equivalent Time Sampling (ETS) block mode data with or without downsampling starting at the specified sample number.

Memory for the data arrays is allocated and the driver is informed where to store the data prior to retrieval. Data collection with more than one downsampling mode is NOT supported by this function. Aggregated data collection is not supported when using ETS mode. 

This function can be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Block group.
startIndex - a zero-based index that indicates the start point for data collection. Use zero to start at the first sample.
segmentIndex - the number of the memory segment to be used/where the data is stored. Use 0 if the memory has not been segmented.
ratio - the downsampling factor that will be applied to the raw data.
ratioMode - which downsampling mode to use (specified by an enumeration from the enPS2000ARatioMode range of enumerations excluding PS2000A_RATIO_MODE_AGGREGATE).

Output parameters:

numSamples - the number of samples retrieved from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.
etsTimes - an array containing the times (in femtoseconds) at which each sample was captured.
channelA - an array containing data values (in millivolts) for channel A.
channelB - an array containing data values (in millivolts) for channel B.
channelC - an array containing data values (in millivolts) for channel C.
channelD - an array containing data values (in millivolts) for channel D.

Channels not enabled or not supported by the device (e.g. channels C and D for a 2-channel oscilloscope) will be returned as an empty array.

Please also refer to the ps2000aSetDataBuffer, ps2000aSetEtsTimeBuffer, and ps2000aGetValues functions in the please refer to the PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.</Description>
            </Method>
            <Method>
               <Name>ps2000aGetTriggerTimeOffset</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeUpper, timeLower, timeUnits] = ps2000aGetTriggerTimeOffset(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    timeUpper = 0;
    timeLower = 0;
    timeUnits = 0;
    
    [status, timeUpper, timeLower, timeUnits] = calllib('ps2000a', ...
        'ps2000aGetTriggerTimeOffset', deviceObj.DriverData.unitHandle, ...
        timeUpper, timeLower, timeUnits, segmentIndex);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aGetTriggerTimeOffset:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end
</MCode>
               </Code>
               <Description>ps2000aGetTriggerTimeOffset(obj, segmentIndex) gets the time, as two 4-byte values, at which the trigger occurred.

Call it after block-mode data has been captured or when data has been retrieved from a previous block-mode capture. 
Using the 64-bit version of this function, ps2000aGetTriggerTimeOffset64(), is recommended.

The time offset of a waveform is the delay from the trigger sampling instant to the time at which the driver estimates the
waveform to have crossed the trigger threshold. You can add this offset to the time of each sample in the waveform to reduce trigger jitter. Without using the time offset, trigger jitter can be up to 1 sample period; adding the time offset reduces jitter to a small fraction of a sample period.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Block group.
segmentIndex - the number of the memory segment for which the information is required.

Output Arguments:

status - status code returned by the driver.
timeUpper - the upper 32 bits of the time at which the trigger point occurred.
timeLower - the lower 32 bits of the time at which the trigger point occurred.
timeUnits - the time units in which timeUpper and timeLower are measured (represented by an enPS2000ATimeUnits enumeration value).</Description>
            </Method>
            <Method>
               <Name>ps2000aGetTriggerTimeOffset64</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, time, timeUnits] = ps2000aGetTriggerTimeOffset64(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    time = 0;
    timeUnits = 0;

    [status, timeUnits] = calllib('ps2000a', ...
        'ps2000aGetTriggerTimeOffset64', deviceObj.DriverData.unitHandle, ...
        time, timeUnits, segmentIndex);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aGetTriggerTimeOffset64:- status code: %d. Please refer to the PicoStatus.m file.', status);  
        
    end</MCode>
               </Code>
               <Description>ps2000aGetTriggerTimeOffset64(obj, segmentIndex)  gets the time, as a single 64-bit value, at which the trigger occurred.

Call it after block-mode data has been captured or when data has been retrieved from a previous block-mode capture. 

The time offset of a waveform is the delay from the trigger sampling instant to the time at which the driver estimates the
waveform to have crossed the trigger threshold. You can add this offset to the time of each sample in the waveform to reduce trigger jitter. Without using the time offset, trigger jitter can be up to 1 sample period; adding the time offset reduces jitter to a small fraction of a sample period.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Block group.
segmentIndex -  the number of the memory segment for which the information is required.

Output Arguments:

status - status code returned by the driver.
time - the time at which the trigger point occurred.
timeUnits - the time units in which time is measured (represented by an enPS2000ATimeUnits enumeration value).</Description>
            </Method>
            <Method>
               <Name>ps2000aGetValues</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps2000aGetValues(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    pNumSamples = libpointer('uint32Ptr', noOfSamples);
    pOverflow = libpointer('int16Ptr', 0);
    
    [status] = calllib('ps2000a', 'ps2000aGetValues', ...
        deviceObj.DriverData.unitHandle, startIndex, pNumSamples, downSampleRatio, ....
        downSampleRatioMode, segmentIndex, pOverflow);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aGetValues:- status code: %d. Please refer to the PicoStatus.m file.', status);   
    
    else
        
        overflow = pOverflow.Value;
        numSamples = pNumSamples.Value;
        
    end</MCode>
               </Code>
               <Description>ps2000aGetValues(obj, startIndex, noOfSamples, downSampleRatio, downSampleRatioMode, segmentIndex) returns block-mode data, with or without downsampling, starting at the specified sample number.

Use this function if you need to set up data buffers prior to starting data collection, otherwise consider using the getBlockData function which sets up data buffers and retrieves the data converted to millivolts.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Block group.
startIndex - a zero-based index that indicates the start point for data collection.
noOfSamples - the number of samples required.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by an enPS2000ARatioMode enumeration value).
segmentIndex - the zero-based number of the memory segment where the data is stored.

Output Arguments:

status - status code returned by the driver.
numSamples - the actual number of samples retrieved from the driver. The number of samples retrieved will
not be more than the number requested, and the data retrieved starts at startIndex.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels. It is a bit field with
bit 0 denoting Channel A.</Description>
            </Method>
            <Method>
               <Name>ps2000aIsReady</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, ready] = ps2000aIsReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    ready = 0; % Initialise value for pointer
    
    [status, ready] = calllib('ps2000a', 'ps2000aIsReady', ...
                            deviceObj.DriverData.unitHandle, ready);

    if (status == PicoStatus.PICO_OK || status == PicoStatus.PICO_BUSY)

        % Do nothing

    else

        error('ps2000aIsReady:- status code: %d. Please refer to the PicoStatus.m file.', status); 

    end
                        
</MCode>
               </Code>
               <Description>ps2000aIsReady(obj) indicates if the driver has finished collecting the requested samples.

Use this function to poll the driver to indicate if block data collection has finished if using the ps2000aRunBlock function, which should be called prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Block group.

Output Arguments:

status - status code returned by the driver.
ready - zero, the if device is still collecting. Non-zero, the device has finished collecting.
</Description>
            </Method>
            <Method>
               <Name>ps2000aRunBlock</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIndisposedMs] = ps2000aRunBlock(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    oversample = 1;
    timeIndisposedMs = 0;   % Initialise to pass as pointer.
    lpReady = [];           % Set to NULL - Callback function not used.
    pParameter = [];        % Set to NULL - Callback function not used.
    
    unitHandle = deviceObj.DriverData.unitHandle;
    timebaseIndex = deviceObj.DriverData.timebase;
    preTriggerSamples = deviceObj.DriverData.numPreTriggerSamples;
    postTriggerSamples = deviceObj.DriverData.numPostTriggerSamples;
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('runBlock:- Collecting block of data:\n\tTimebase: %u\n\tPre-trigger samples: %u\n\tPost-trigger samples: %u\n', ...
            timebaseIndex, preTriggerSamples, postTriggerSamples);
        
    end

    [status, timeIndisposedMs] = calllib('ps2000a', 'ps2000aRunBlock', ...
        unitHandle, preTriggerSamples, postTriggerSamples, timebaseIndex, ...
        oversample, timeIndisposedMs, segmentIndex, lpReady, pParameter);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps2000aRunBlock:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps2000aRunBlock(obj, segmentIndex) starts collecting data in block mode.

If additional code does not need to be called prior to the device indicating that it has collected data, use the runBlock function in place of this function and the ps2000aIsReady function.

This function can be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Block group.
segmentIndex - zero-based index, specifying which memory segment to use. Set this parameter to 0, if memory has not been segmented.

Output Arguments:

status - 0 if the ps2000aRunBlock and ps2000aIsReady functions have been executed correctly. 
timeIndisposedMs - the time, in milliseconds, that the scope will spend collecting samples. This does not include any auto trigger timeout and is not valid in ETS capture mode.

For further information on the ps2000aRunBlock function please refer to the PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.</Description>
            </Method>
            <Method>
               <Name>ps2000aSetEts</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, sampleTimePicoSeconds] = ps2000aSetEts(obj, mode, etsCycles, etsInterleave)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    sampleTimePicoSeconds = 0; % Initialise to pass as pointer
    
    unitHandle = deviceObj.DriverData.unitHandle;
    
    if(mode == deviceObj.DriverData.enums.enPS2000AEtsMode.PS2000A_ETS_OFF)
        
        [status, sampleTimePicoSeconds] = calllib('ps2000a', 'ps2000aSetEts', ...
                unitHandle, mode, etsCycles, etsInterleave, sampleTimePicoSeconds);
    
    elseif(etsCycles &gt; 0 &amp;&amp; etsInterleave &gt; 0)
    
        maxEtsCycles = deviceObj.DriverData.maxEtsCycles;
        % maxEtsInterleave = 0;
        
        % Find maximum ETS cycles and ETS interleave for device
        %[status, maxEtsCycles, maxEtsInterleave] = calllib('ps2000a', ...
        %        'ps2000aGetMaxEtsValues', unitHandle, maxEtsCycles, maxEtsInterleave);

        if(etsCycles &gt; maxEtsCycles)
            
            error('ps2000aSetEts: Number of ETS cycles has exceeded the maximum (%d).', maxEtsCycles);
            
        end
        
        %{
        if(etsInterleave &gt; maxEtsInterleave) 
            
            error('ps2000aSetEts: Number of waveforms has exceeded the maximum (%d).', maxEtsInterleave);
            
        end
        %}
        
        [status, sampleTimePicoSeconds] = calllib('ps2000a', 'ps2000aSetEts', ...
                unitHandle, mode, etsCycles, etsInterleave, sampleTimePicoSeconds);
            
        if(status ~= PicoStatus.PICO_OK)
           
            error('ps2000aSetEts:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
        end
        
    else
        
        error('ps2000aSetEts: etsCycles and etsInterleave must both be greater than 0.')
        
    end</MCode>
               </Code>
               <Description>ps2000aSetEts(obj, mode, etsCycles, etsInterleave) is used to enable or disable ETS (equivalent-time sampling) and to set the ETS parameters.

ETS mode cannot be used when MSO digital ports are enabled.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Block group.
mode - must be one of the following:

	PS2000A_ETS_OFF    (0)
	PS2000A_ETS_FAST  (1)
	PS2000A_ETS_SLOW (2)

etsCycles - the number of cycles to store; must be greater than zero and between 2 and 5 times greater than etsInterleave.
etsInterleave - the number of waveforms to combine into a single ETS capture. Must be greater than zero.

Output parameters:

status - status code returned by the driver.
sampleTimePicoSeconds - the effective sampling interval of the ETS data.

For further information on the ps2000aSetEts function please refer to the  PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.
</Description>
            </Method>
            <Method>
               <Name>ps2000aSetEtsTimeBuffer</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status] = ps2000aSetEtsTimeBuffer(obj, pEtsTimeBuffer)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
    
    deviceObj = get(obj, 'Parent');

    status = calllib('ps2000a', 'ps2000aSetEtsTimeBuffer', ...
        deviceObj.DriverData.unitHandle, pEtsTimeBuffer, length(pEtsTimeBuffer.Value));
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aSetEtsTimeBuffer:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end</MCode>
               </Code>
               <Description>ps2000aSetEtsTimeBuffer(obj, pEtsTimeBuffer) tells the driver where to find your application's ETS time buffers.

These buffers contain the 64-bit timing information for each ETS sample after you run a block-mode ETS capture.

Input Arguments:

obj - the object representing the Block group.
pEtsBuffer - a libpointer object corresponding to a 1-D array of 64-bit words, each representing the time in femtoseconds (e-15 s) at which the sample was captured.

Output Arguments:

status - status code returned by the driver.


Consider using the getEtsBlockData() function if time and data buffers do not need to be set up prior to the start of data collection.</Description>
            </Method>
            <Method>
               <Name>ps2000aSetEtsTimeBuffers</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status] = ps2000aSetEtsTimeBuffers(obj, pEtsTimeBufferUpper, pEtsTimeBufferLower)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Compare lengths of arrays
    if (length(pEtsTimeBufferUpper.Value) ~= length(pEtsTimeBufferLower.Value))
       
        error('PS2000aSetTimeBuffers:BufferLengthsNotEqual', ...
            'ps2000aSetTimeBuffers - buffer lengths are not equal');
        
    end

    status = calllib('ps2000a', 'ps2000aSetEtsTimeBuffers', ...
        deviceObj.DriverData.unitHandle, pEtsTimeBufferUpper, ...
        pEtsTimeBufferLower, length(pEtsTimeBufferUpper.Value));
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aSetEtsTimeBuffers:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps2000aSetEtsTimeBuffers(obj, pEtsTimeBufferUpper, pEtsTimeBufferLower) tells the driver where to find your application's ETS time buffers. These buffers contain the timing information for each ETS sample after you run a block mode ETS capture.

Using the ps2000aSetEtsTimeBuffer function is recommended.

Input Arguments:

obj - the object representing the Block group.
pEtsTimeBufferUpper - an array of 32-bit words, each representing the upper 32 bits of the time in femtoseconds (e-15 s) at which the sample was captured.
pEtsTimeBufferLower - an array of 32-bit words, each representing the lower 32 bits of the time in femtoseconds (e-15 s) at which the sample was captured.

Output Arguments:

status - status code returned by the device.
</Description>
            </Method>
            <Method>
               <Name>runBlock</Name>
               <Location>block</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, timeIndisposedMs] = runBlock(obj, segmentIndex)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    oversample = 1;
    timeIndisposedMs = 0;   % Initialise to pass as pointer.
    lpReady = [];           % Set to NULL - Callback function not used.
    pParameter = [];        % Set to NULL - Callback function not used.
    
    unitHandle = deviceObj.DriverData.unitHandle;
    timebaseIndex = deviceObj.DriverData.timebase;
    preTriggerSamples = deviceObj.DriverData.numPreTriggerSamples;
    postTriggerSamples = deviceObj.DriverData.numPostTriggerSamples;
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('runBlock:- Collecting block of data:\n\tTimebase: %u\n\tPre-trigger samples: %u\n\tPost-trigger samples: %u\n', ...
            timebaseIndex, preTriggerSamples, postTriggerSamples);
        
    end

    [runBlockStatus, timeIndisposedMs] = calllib('ps2000a', 'ps2000aRunBlock', ...
        unitHandle, preTriggerSamples, postTriggerSamples, timebaseIndex, ...
        oversample, timeIndisposedMs, segmentIndex, lpReady, pParameter);
    
    if (runBlockStatus ~= PicoStatus.PICO_OK)
           
        error('runBlock:- ps2000aRunBlock returned with status code: %d. Please refer to the PicoStatus.m file.', runBlockStatus); 
        
    end
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('runBlock: Waiting for device to become ready...\n');
        
    end
    
    ready = 0; % Initialise value for pointer
    
    while(ready == 0)
        
        [readyStatus, ready] = calllib('ps2000a', 'ps2000aIsReady', ...
                                unitHandle, ready);
                        
        if( readyStatus == PicoStatus.PICO_OK || readyStatus == PicoStatus.PICO_BUSY)
           
            % Do nothing
            
        else
            
            error('runBlock:- ps2000aIsReady returned with status code: %d. Please refer to the PicoStatus.m file.', readyStatus); 
        
        end
                        
    end
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('runBlock: Device ready.\n\n');
        
    end
    
    % Other conditions would have been captured.
    if (runBlockStatus == PicoStatus.PICO_OK &amp;&amp; readyStatus == PicoStatus.PICO_OK)
        
        status = PicoStatus.PICO_OK;
        
    else
        
        if (runBlockStatus ~= PicoStatus.PICO_OK)
            
            error('runBlock:- ps2000aRunBlock returned with status code: %d\n', runBlockStatus);
            
        else
            
            error('runBlock:- ps2000aIsReady returned with status code: %d\n', readyStatus);
                
        end
            
        
    end;
    
    
    
</MCode>
               </Code>
               <Description>runBlock(obj, segmentIndex) starts collecting data in block mode and returns when the device is ready for data to be collected.

If additional code needs to be called prior to the device indicating that it has collected data, use the ps2000aRunBlock and ps2000aIsReady function.

This function can be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Block group.
segmentIndex - zero-based index, specifying which memory segment to use. Set this parameter to 0, if memory has not been segmented.

Output Arguments:

status - status code returned by the driver.

</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>digital</Name>
         <Description>The Digital group contains a set of properties and functions related to the digital ports of the device (applicable to MSO models only).</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Digital1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>digitalPortSettings</Name>
               <Location>digital</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.digitalPortSettings;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>A matrix containing the port settings for digital ports.

This will consist of a 2 x 2 matrix.

The row number will correspond to the port:

1 - Port 0
2 - Port 1

Each row will contain the following elements corresponding to:

enabled - set to 0 (off) or 1 (on).
logicLevel - set in the range -5 V to 5 V.</Description>
            </Property>
            <Property>
               <Name>maxLogicLevel</Name>
               <Location>digital</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.maxLogicLevel;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>32767</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The maximum count level for a digital port (corresponding to +5 V).</Description>
            </Property>
            <Property>
               <Name>minLogicLevel</Name>
               <Location>digital</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.minLogicLevel;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>-32767</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The minimum count level for a digital port (corresponding to -5 V).</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>ps2000aSetDigitalPort</Name>
               <Location>digital</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000aSetDigitalPort(obj, port, enabled, logicLevel)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    logicLevelCount = int16((logicLevel / deviceObj.DriverData.constants.PS2000A_MAX_LOGIC_VOLTAGE) ...
        * deviceObj.DriverData.maxLogicLevel);
    
    status = calllib('ps2000a', 'ps2000aSetDigitalPort', ...
        deviceObj.DriverData.unitHandle, port, enabled, logicLevelCount);
    
    % Obtain digital port settings information 
    dpSettings = deviceObj.DriverData.digitalPortSettings;
    
    % Only process if status is ok.
	if (status == PicoStatus.PICO_OK)
        
        switch (port)
            
            case deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT0
                
                dpSettings(1,1) = enabled;
                dpSettings(1,2) = logicLevelCount;
                
            case deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT1
                
                dpSettings(2,1) = enabled;
                dpSettings(2,2) = logicLevelCount;
                
             otherwise
                
                % Do nothing
                    
        end
        
        deviceObj.DriverData.digitalPortSettings = dpSettings;
        
        % Information to be passed to the wrapper dll
        enabledDigitalPorts = zeros(PicoConstants.QUAD_SCOPE, 1, 'int16');
        
        enabledDigitalPorts = [dpSettings(1,1); ...
                    dpSettings(2,1); 0; 0];
        
        % Pass information to wrapper dll
        setEnabledDigitalPortsStatus = calllib('ps2000aWrap', 'setEnabledDigitalPorts', ...
            deviceObj.DriverData.unitHandle, enabledDigitalPorts);
                
    else
       
        error('ps2000aSetDigitalPort: status code %d\n', status);
        
    end
    
    </MCode>
               </Code>
               <Description>ps2000aSetDigitalPort(obj, port, enabled, logicLevel) is used to enable the digital port and set the logic level (the voltage point at which the state transitions from 0 to 1 for a digital channel).

This function is for MSO devices only and is not compatible with ETS mode.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Digital group.
port - the port for digital data (either the enumeration enPS2000ADigitalPort.PS2000A_DIGITAL_PORT0 or enPS2000ADigitalPort.PS2000A_DIGITAL_PORT1).
enabled - set to TRUE (1) to enable the channel, FALSE (0) otherwise.
logicLevel - the voltage at which the state transitions between 0 and 1. Range: -5V to 5V.

Output Arguments:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>setDigitalPortDefaults</Name>
               <Location>digital</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setDigitalPortDefaults(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('Default Digital Port Setup:-\n');
        fprintf('----------------------------\n\n');
        
    end

    dPort0 = deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT0;
    dPort1 = deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT1;
    
    true  = PicoConstants.TRUE;
    logicLevelVoltage = 1.5; % Default value (Volts)
    
    % Matrix of values to represent digital ports (rows) x properties (cols)
    deviceObj.DriverData.digitalPortSettings = zeros(deviceObj.DriverData.digitalPortCount, 2);

    % Set Digital Ports count updating internal settings
    % Parameters are enabled and logic level.

    % Update internal settings
    
    % Create a number of ports x fields array
    dpSettings = zeros(deviceObj.DriverData.digitalPortCount, 2);
    
    for ch = 1:deviceObj.DriverData.digitalPortCount
        
        digiPortSettings(ch).enabled = true;
        digiPortSettings(ch).logicLevel = logicLevelVoltage;
        
        % Transpose the resulting array for the channel and combine
        dpSettings(ch, :) = cell2mat(struct2cell(digiPortSettings(ch)))';

    end
    
    deviceObj.DriverData.digitalPortSettings = dpSettings;
    
    status = zeros(deviceObj.DriverData.digitalPortCount, 1);
    
    status(1) = invoke(obj, 'ps2000aSetDigitalPort', dPort0, true, logicLevelVoltage);
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('PORT0:-\n\tEnabled: True\n\tLogic Level: +1.5 V\n\n');
        
    end

    status(2) = invoke(obj, 'ps2000aSetDigitalPort', dPort1, true, logicLevelVoltage);
    
    if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
        fprintf('PORT1:-\n\tEnabled: True\n\tLogic Level: +1.5 V\n\n');
        
    end

    % Clear local variables
    
    clear true;
    clear logicLevel;
        
</MCode>
               </Code>
               <Description>setDigitalPortDefaults(obj) sets the following default values for any digital ports found on the device:

Digital Port:

Enabled               : True
Logic Level	: +1.5 V

Input Arguments:

obj - the object representing the Digital group.

Output Arguments:

status - status code returned by the driver.
</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>rapidblock</Name>
         <Description>The Rapidblock group contains a set of properties and functions related to the rapid block mode capture functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="rapidblock" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>getRapidBlockData</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, overflow, channelA, channelB, channelC, channelD, dPort0, dPort1] = getRapidBlockData(obj, numCaptures, ratio, ratioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Check ratio mode is not aggregated
    if (ratioMode ~= deviceObj.DriverData.enums.enPS2000ARatioMode.PS2000A_RATIO_MODE_AGGREGATE)

        unitHandle = deviceObj.DriverData.unitHandle;

        channelCount = deviceObj.DriverData.channelCount;

        portCount = deviceObj.DriverData.digitalPortCount;

        % Retrieve channel settings - channel x data field matrix
        channelSettings = deviceObj.DriverData.channelSettings;

        % Retrieve port settings - port x data field matrix
        portSettings = deviceObj.DriverData.digitalPortSettings;

        % Create empty arrays for channel data.
        channelA = [];
        channelB = [];
        channelC = [];
        channelD = [];

        dPort0 = [];
        dPort1 = [];

        % Initialise variable for array of libpointers
        pABuffer(channelCount, numCaptures) = libpointer;

        if (portCount &gt; 0)

            pDBuffer(portCount, numCaptures) = libpointer;

        end

        % Initialise array for status values
        setBufferStatus = zeros(channelCount, numCaptures, 'uint32');

        % Total number of samples to set for data buffers, taking into
        % account the downsampling ratio 
        totalSamples = ceil((deviceObj.DriverData.numPreTriggerSamples + ...
            deviceObj.DriverData.numPostTriggerSamples)/ratio);

        % Create a 2D matrix of libpointers to allocate memory space for
        % each channel and segment combination
        for segment = 1:numCaptures

            for ch = 1:channelCount

                % Set Data Buffer if channel is enabled
                if (channelSettings(ch, 1) == PicoConstants.TRUE)

                    % Store array of libpointers
                    pABuffer(ch, segment) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));

                    setBufferStatus(ch, segment) = calllib('ps2000a', 'ps2000aSetDataBuffer', ...
                        unitHandle, (ch - 1), pABuffer(ch, segment), totalSamples, ...
                        (segment - 1), ratioMode);

                    if (setBufferStatus(ch, segment) ~= PicoStatus.PICO_OK)

                        error('getRapidBlockData:- Set Data Buffer for Channel %d Segment % status code: %d', ...
                            (ch - 1), (segment - 1), setBufferStatus);

                    end

                end

            end

            for port = 1:portCount

                % Set Data Buffer if channel is enabled - index 1 indicates if
                % channel is enabled
                if (portSettings(port,1) == PicoConstants.TRUE)

                    % Store array of libpointers
                    pDBuffer(port, segment) = libpointer('int16Ptr', zeros(totalSamples, 1, 'int16'));

                    setBufferStatus = calllib('ps2000a', 'ps2000aSetDataBuffer', ...
                        unitHandle, (port - 1 + deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT0), ... 'PORT0 = 128, PORT1 = 129
                        pDBuffer(port, segment), totalSamples, (segment-1), ratioMode);

                    if (setBufferStatus ~= PicoStatus.PICO_OK)

                        error('getRapidBlockData:- Set Data Buffer for Port %d Segment % status code: %d', ...
                            (port - 1), (segment - 1), setBufferStatus);

                    end

                end

            end

        end

        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
        
            fprintf('getRapidBlockData: Retrieving data...\n');
            
        end

        fromSegmentIndex = 0;
        toSegmentIndex = numCaptures - 1;

        overflowSize = (toSegmentIndex - fromSegmentIndex) + 1;
        overflowPtr = libpointer('int16Ptr', zeros(overflowSize, 1, 'int16'));
        overflow = 0;

        % Call ps2000aGetValuesBulk
        [getValuesBulkStatus, numSamples] = calllib('ps2000a', ...
            'ps2000aGetValuesBulk', unitHandle, totalSamples, fromSegmentIndex, ...
            toSegmentIndex, ratio, ratioMode, overflowPtr);

        overflow = overflowPtr.Value;

        if (getValuesBulkStatus == PicoStatus.PICO_OK)

            if (portCount &gt; 0 &amp;&amp; deviceObj.DriverData.displayOutput == PicoConstants.TRUE)

                fprintf('getRapidBlockData: Retrieving digital port data and assigning to port array.\n');

            end

            for port = 1:portCount

                if (portSettings(port,1) == PicoConstants.TRUE)

                    % Obtain a cell array representing the waveforms for
                    % the channel

                    bufferCells = get(pDBuffer(port, :),'Value');

                    % Combine the cell contents into a total_samples x
                    % numCaptures array               

                    if (numCaptures &gt; 1)

                        bufferCells = horzcat(bufferCells{1:end});                    

                    end


                    switch (port - 1 + deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT0)

                        case deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT0

                            dPort0 = bufferCells;

                        case deviceObj.DriverData.enums.enPS2000ADigitalPort.PS2000A_DIGITAL_PORT1

                            dPort1 = bufferCells;

                        otherwise

                            % Do nothing

                    end

                end

            end

            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getRapidBlockData: Converting analog channels to millivolts and assigning to channel array.\n');
                
            end

            % Obtain max ADC count value
            maxADCValue = double(deviceObj.DriverData.maxADCValue);

            % Retrieve data values for enabled channels
            for ch = 1:channelCount

                if (channelSettings(ch,1) == PicoConstants.TRUE)

                    scopeInputIndex = channelSettings(ch, 3) + 1;
                    voltageRange = PicoConstants.SCOPE_INPUT_RANGES(scopeInputIndex);

                    % Obtain a cell array representing the waveforms for
                    % the channel

                    bufferCells = get(pABuffer(ch, :),'Value');

                    % Combine the cell contents into a total_samples x
                    % numCaptures array               

                    if (numCaptures &gt; 1)

                        bufferCells = horzcat(bufferCells{1:end});                    

                    end

                    bufferValues = adc2mv(bufferCells, voltageRange, maxADCValue);

                    switch(ch - 1)

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_A

                            channelA = bufferValues;

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_B

                            channelB = bufferValues;

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_C

                            channelC = bufferValues;

                        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_D

                            channelD = bufferValues;

                        otherwise

                            % Do nothing

                    end               

                end

            end

            if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
                
                fprintf('getRapidBlockData: Data succesfully retrieved.\n\n');
                
            end

            clear pABuffer;
            clear pDBuffer
            clear bufferValues;
            clear bufferCells;

        else

            error('getRapidBlockData:- Error retrieving data values, status code: %d', getValuesBulkStatus);

        end


    else

        error('getRapidBlockData: Aggregate Mode data collection not supported by this function.');

    end</MCode>
               </Code>
               <Description>getRapidBlockData(obj, numCaptures, ratio, ratioMode) retrieves waveforms captured using rapid block mode. The waveforms must have been collected sequentially and in the same run.

Memory for the data arrays from segment index 0 to numCaptures - 1 is allocated and the driver is informed where to store the data prior to retrieval. Data collection in Aggregation mode or with more than one downsampling mode  is NOT supported by this function.

Channel data will be returned as an array in the form numSamples x numCaptures. Channels not enabled or not supported by this device will be returned as an empty array.

This function can be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Rapidblock group.
numCaptures - the number of waveform captures to retrieve.
ratio - the downsampling factor that will be applied to the raw data.
ratioMode - which downsampling mode to use (specified by an enumeration from the enPS2000ARatioMode set excluding PS2000A_RATIO_MODE_AGGREGATE).

Output Arguments:

status - status code returned by the driver.
numSamples - the number of samples retrieved per waveform from the driver.
overflow - a set of flags that indicate whether an overvoltage has occurred on any of the channels.
channelA - an array containing data values (in millivolts) for channel A.
channelB - an array containing data values (in millivolts) for channel B.
channelC - an array containing data values (in millivolts) for channel C.
channelD - an array containing data values (in millivolts) for channel D.
portD0 - an array containing data values in binary format for digital Port 0 (in MSB order)
portD1 - an array containing data values in binary format for digital Port 1 (in MSB order)

Please also refer to the and ps2000aGetValuesBulk and ps2000aSetDataBuffer  functions in the PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.</Description>
            </Method>
            <Method>
               <Name>ps2000aGetNoOfCaptures</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nCaptures] = ps2000aGetNoOfCaptures(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    nCaptures = 0; % Value for pointer.

    [status, nCaptures] = calllib('ps2000a', 'ps2000aGetNoOfCaptures', ...
                            unitHandle, nCaptures);
                        
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aGetNoOfCaptures:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end
</MCode>
               </Code>
               <Description>ps2000aGetNoOfCaptures(obj) finds out how many captures are available in rapid block mode after ps2000aRunBlock or runBlock has been called when either the collection completed or the collection of waveforms was interrupted by calling ps2000aStop.

The returned value (nCaptures) can then be used to iterate through the number of segments using
ps2000aGetValues, or in a single call to ps2000aGetValuesBulk where it is used to
calculate the toSegmentIndex parameter.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Rapidblock group.

Output Arguments

status - status code returned by the driver.
nCaptures - the number of available captures that has been collected from calling runBlock or ps2000aRunBlock.</Description>
            </Method>
            <Method>
               <Name>ps2000aGetNoOfProcessedCaptures</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, nProcessedCaptures] = ps2000aGetNoOfProcessedCaptures(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    nProcessedCaptures = 0;

    [status, nProcessedCaptures] = calllib('ps2000a', 'ps2000aGetNoOfProcessedCaptures', ...
        unitHandle, nProcessedCaptures);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aGetNoOfProcessedCaptures:- status code: %d. Please refer to the PicoStatus.m file.', status);  
        
    end
</MCode>
               </Code>
               <Description>ps2000aGetNoOfProcessedCaptures(obj) gets the number of captures collected and processed in one run of rapid
block mode. It enables your application to start processing captured data while the driver is still transferring later captures from the device to the computer. 

The function returns the number of captures the driver has processed since you called ps2000aRunBlock. It is for use in rapid block mode, alongside the ps2000aGetValuesOverlappedBulk function, when the driver is set to transfer data from the device automatically as soon as the ps2000aRunBlock function is called. You can call ps2000aGetNoOfProcessedCaptures during device capture, after collection
has completed or after interrupting waveform collection by calling ps2000aStop. 

The returned value (nProcessedCaptures) can then be used to iterate through the number of segments using ps2000aGetValues, or in a single call to ps2000aGetValuesBulk, where it is used to calculate the toSegmentIndex parameter. 

When capture is stopped

If nProcessedCaptures = 0, you will also need to call ps2000aGetNoOfCaptures, in
order to determine how many waveform segments were captured, before calling
ps2000aGetValues or ps2000aGetValuesBulk.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Rapidblock group.

Output parameters:

status - status code returned by the driver.
nProcessedCaptures - the number of waveforms captured and processed.</Description>
            </Method>
            <Method>
               <Name>ps2000aGetValuesBulk</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, numSamples, overflow] = ps2000aGetValuesBulk(obj, noOfSamples, fromSegmentIndex, toSegmentIndex, downSampleRatio, downSampleRatioMode)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;

    % overflow must be an array
    overflowSize = (toSegmentIndex - fromSegmentIndex) + 1;
    overflowPtr = libpointer('int16Ptr', zeros(overflowSize, 1));
    overflow = 0;

    [status, numSamples] = calllib('ps2000a', 'ps2000aGetValuesBulk', ...
        unitHandle, noOfSamples, fromSegmentIndex, toSegmentIndex, ... 
        downSampleRatio, downSampleRatioMode, overflowPtr);
    
    if (status == PicoStatus.PICO_OK)
        
        overflow = get(overflowPtr, 'Value');
        
    else
           
        error('ps2000aGetValuesBulk:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps2000aGetValuesBulk(obj, noOfSamples, fromSegmentIndex, toSegmentIndex, downSampleRatio, downSampleRatioMode) retrieves waveforms captured using rapid block mode. The waveforms must have been collected sequentially and in the same run.

Input Arguments:

obj - the object representing the Rapidblock group.
noOfSamples - the number of samples required.
fromSegmentIndex - the first segment from which the waveform should be retrieved.
toSegmentIndex - the last segment from which the waveform should be retrieved.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by enPS2000aRatioMode enumeration).

Output Arguments:

status - status code returned by the driver.
numSamples - the actual number of samples per waveform retrieved from the driver.
overflow - an array of integers equal to or larger than the number of waveforms to be retrieved with each element corresponding to an overflow value as described in the ps2000aGetValues function.</Description>
            </Method>
            <Method>
               <Name>ps2000aGetValuesOverlappedBulk</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status] = ps2000aGetValuesOverlappedBulk(obj, startIndex, pNumSamples, downSampleRatio, downsampleRatioMode, fromSegmentIndex, toSegmentIndex, pOverflow)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;

    status = calllib('ps2000a', 'ps2000aGetValuesBulk', ...
        unitHandle, pNumSamples, downSampleRatio, downSampleRatioMode, ...
        fromSegmentIndex, toSegmentIndex, pOverflow);
    
    if (status == PicoStatus.PICO_OK)
        
        % Do nothing
        
    else
           
        error('ps2000aGetValuesOverlappedBulk:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>ps2000aGetValuesOverlappedBulk(obj, startIndex, downSampleRatio, downsampleRatioMode, fromSegmentIndex, toSegmentIndex) allows you to make a deferred data-collection request, which will later be executed, and the arguments validated, when you call ps2000aRunBlock in rapid block mode. The advantage of this method is that the driver makes contact with the scope only once, when you call ps2000aRunBlock, compared with the two contacts that occur when you use the conventional ps2000aRunBlock, ps2000aGetValuesBulk calling sequence. This slightly reduces the dead time between successive captures in rapid block mode.

After calling ps2000aRunBlock, you can optionally use ps2000aGetValues to request
further copies of the data. This might be required if you wish to display the data with
different data reduction settings. 

Input Arguments:

obj - the object representing the Rapidblock group.
startIndex - a zero-based index that indicates the start point for data collection. It is measured in sample intervals from the start of the buffer.
numSamples - a libpointer object representing the number of raw samples to be collected before any downsampling is applied. On exit, this will represent the actual number in the buffer. The number of samples retrieved will not be
more than the number requested, and the data retrieved starts at startIndex.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode - which downsampling mode to use (specified by enumeration).
fromSegmentIndex - the first segment from which the waveform should be retrieved.
toSegmentIndex - the last segment from which the waveform should be retrieved.
overflow - a libpointer object to an array of integers equal to or larger than the number of waveforms to be retrieved with each element corresponding to an overflow value as described in the ps2000aGetValues function.

Output Arguments:

status - status code returned by the driver.



 

</Description>
            </Method>
            <Method>
               <Name>ps2000aSetNoOfCaptures</Name>
               <Location>rapidblock</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000aSetNoOfCaptures(obj, nCaptures)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;

    status = calllib('ps2000a', 'ps2000aSetNoOfCaptures', ...
        unitHandle', nCaptures);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aSetNoOfCaptures:- status code: %d. Please refer to the PicoStatus.m file.', status);  
        
    end</MCode>
               </Code>
               <Description>ps2000aSetNoOfCaptures(obj, nCaptures) sets the number of captures to be collected in one run of rapid block mode. If you do not call this function before a run, the driver will capture only one waveform. Once a value has been set, the value remains constant unless changed.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Rapidblock group.
nCaptures - the number of waveforms to capture in one run.

Output Arguments:

status - status code returned by the driver.
</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>signalgenerator</Name>
         <Description>The Signalgenerator group contains a set of properties and functions related to the signal generator functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="signalgenerator" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>awgBufferSize</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.awgBufferSize;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="32768.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>16384</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The size of the arbitrary waveform buffer on the device, in samples.</Description>
            </Property>
            <Property>
               <Name>dacFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.dacFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2.0E7" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2E7</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The update frequency of the Arbitrary Waveform Generator (MS/s or MHz).</Description>
            </Property>
            <Property>
               <Name>ddsFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.ddsFrequency;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>ddsFrequency is the direct digital synthesis frequency for the arbitrary waveform generator (in Hz). This property is only set for the PicoScope 2205 MSO, and is set to 0 for other models.</Description>
            </Property>
            <Property>
               <Name>offsetVoltage</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.offsetVoltage;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.offsetVoltage = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="2000.0" Min="-2000.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The voltage offset, in millivolts, to be applied to the waveform.

The amplitude of the waveform should not exceed +/-2000 mV.</Description>
            </Property>
            <Property>
               <Name>peakToPeakVoltage</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.peakToPeakVoltage;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.peakToPeakVoltage = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="4000.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2000.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The peak-to-peak voltage, in millivolts, of the waveform signal.

The amplitude of the waveform should not exceed +/-2000 mV.</Description>
            </Property>
            <Property>
               <Name>sigGenType</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.sigGenType;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.
</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                     <Value>2.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The type of Signal Generator on the device:

0 - None
1 - Function Generator
2 - Arbitrary Waveform Generator</Description>
            </Property>
            <Property>
               <Name>startFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.startFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.startFrequency = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="1000000.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The frequency that the signal generator will initially produce (hertz).</Description>
            </Property>
            <Property>
               <Name>stopFrequency</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.stopFrequency;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.stopFrequency = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="1000000.0" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1000</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The frequency at which the sweep reverses direction or returns to the initial frequency (hertz).

To output a signal with constant frequency, ensure that stopFrequency is equal to startFrequency.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>ps2000aSigGenSoftwareControl</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = ps2000aSigGenSoftwareControl(obj, state)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    status = calllib('ps2000a', 'ps2000aSigGenSoftwareControl', ...
                deviceObj.DriverData.unitHandle, state);
            
	if (status ~= PicoStatus.PICO_OK)
           
        error('ps2000aSigGenSoftwareControl:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end </MCode>
               </Code>
               <Description>ps2000aSigGenSoftwareControl(obj, state) causes a trigger event, or starts and stops gating. Use it as follows:

1. Call ps2000aSetSigGenBuiltIn or ps2000aSetSigGenArbitrary to set up the
signal generator, setting the triggerSource argument to enPS2000ASigGenTrigSource.SIGGEN_SOFT_TRIG. 

2. (a) If you set the signal generator triggerType to edge triggering (enPS2000ASigGenTrigType.PS2000A_SIGGEN_RISING or enPS2000ASigGenTrigType.PS2000A_SIGGEN_FALLING), call ps2000aSigGenSoftwareControl once to trigger the signal generator output. 

(b) If you set the signal generator triggerType to gated triggering (enPS2000ASigGenTrigType.PS2000A_SIGGEN_GATE_HIGH or enPS2000ASigGenTrigType.PS2000A_SIGGEN_GATE_LOW), call ps2000aSigGenSoftwareControl with state set as follows:

PS2000A_SIGGEN_GATE_HIGH:
 
1 to trigger the output of the signal generator, and then again with state set to 0 to stop the trigger.

PS2000A_SIGGEN_GATE_LOW:

0 to trigger the output of the signal generator, and then again with state set to 1 to stop the trigger.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Signalgenerator group.
state - sets the trigger gate high or low when the trigger type is set to either SIGGEN_GATE_HIGH or SIGGEN_GATE_LOW.

Output Arguments:

status - status code returned by the driver.
</Description>
            </Method>
            <Method>
               <Name>setSigGenArbitrary</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, dwellTime] = setSigGenArbitrary(obj, increment, dwellTime, arbitraryWaveform, sweepType, operation, indexMode, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Only call function if device has an Arbitrary Waveform Generator
    if (deviceObj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)

        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        if (abs(offsetVoltageUV + peakToPeakVoltageUV) &gt; 4000000)
            
            error(['setSigGenArbitrary: The sum of offsetVoltage and ' ...
                'peakToPeakVoltage cannot exceed +/-4000mV.']);
            
        end
        
        maxBufferSize = deviceObj.DriverData.awgBufferSize;
        dacFrequency  = 20e6; % 20 MS/s
        ddsFrequency  = 48e6; % 48 MS/s
        
        % Convert the waveform to the range for the driver
        arbitraryWave = int16(arbitraryWaveform * double(intmax('int16')));
        
        startFrequency = deviceObj.DriverData.startFrequency;

        % Convert start frequency to delta phase value
        pStartDeltaPhase = libpointer('uint32Ptr', 0);
        
        status = calllib('ps2000a', 'ps2000aSigGenFrequencyToPhase', ...
            deviceObj.DriverData.unitHandle, ...
            deviceObj.DriverData.startFrequency, indexMode, ... 
            length(arbitraryWave), pStartDeltaPhase);
        
        if (status ~= PicoStatus.PICO_OK)
           
            error(['setSigGenArbitrary:- ps2000aSigGenFrequencyToPhase ' ...
                '(start freq.) status code: %d. Please refer to the ' ...
                'PicoStatus.m file.'], status);
            
        end
        
        startDeltaPhase = pStartDeltaPhase.Value;

        stopDeltaPhase = 0;
        dwellCount = 0;

        % No need to calculate stop delta phase if start and stop frequencies
        % are the same.
        stopFrequency = deviceObj.DriverData.stopFrequency;
        
        if (stopFrequency == startFrequency)

            stopDeltaPhase = startDeltaPhase;

        else

            % Convert stop frequency to delta phase
            pStopDeltaPhase = libpointer('uint32Ptr', 0);

            status = calllib('ps2000a', 'ps2000aSigGenFrequencyToPhase', ...
                deviceObj.DriverData.unitHandle, ...
                deviceObj.DriverData.stopFrequency, indexMode, ... 
                length(arbitraryWave), pStopDeltaPhase);
            
            error(['setSigGenArbitrary:- ps2000aSigGenFrequencyToPhase ' ...
                '(stop freq.) status code: %d. Please refer to the ' ...
                'PicoStatus.m file.'], status);

            stopDeltaPhase = pStopDeltaPhase.Value;

        end
        
        % Convert increment frequency to delta phase value
        pDeltaPhaseIncrement = libpointer('uint32Ptr', 0);
        
        status = calllib('ps2000a', 'ps2000aSigGenFrequencyToPhase', ...
            deviceObj.DriverData.unitHandle, ...
            increment, indexMode, ... 
            length(arbitraryWave), pDeltaPhaseIncrement);
        
        if (status ~= PicoStatus.PICO_OK)
           
            error(['setSigGenArbitrary:- ps2000aSigGenFrequencyToPhase ' ...
                '(increment freq.) status code: %d. Please refer to the ' ...
                'PicoStatus.m file.'], status);
            
        end
        
        deltaPhaseIncrement = pDeltaPhaseIncrement.Value;

        % Round to the nearest integer
        if (strcmp(deviceObj.InstrumentModel, deviceObj.DriverData.variants.MODEL_PS2205MSO))
            
            dwellCount = round(dwellTime * ddsFrequency);
        
        else
            
            dwellCount = round(dwellTime * dacFrequency); % Round to the nearest integer
            
        end
            
        if (dwellCount &lt; PS2000aConstants.MIN_DWELL_COUNT)

            dwellCount = PS2000aConstants.MIN_DWELL_COUNT;

        end
        
        % Return dwell time information to the user if it has been
        % modified.
        if (strcmp(deviceObj.InstrumentModel, deviceObj.DriverData.variants.MODEL_PS2205MSO))
            
            dwellTime = dwellCount / ddsFrequency;
            
        else
            
            dwellTime = dwellCount / dacFrequency;
            
        end
                
        % Convert extInThresholdMV to counts if device is not an MSO model
        if (deviceObj.DriverData.digitalPortCount &gt; 0)        
            
            extInThreshold = 0;
            
        else
            
            extInThreshold = round(((extInThresholdMV / 1000) / ...
                deviceObj.DriverData.constants.PS2000A_EXT_MAX_VOLTAGE) ...
                * deviceObj.DriverData.constants.PS2000A_EXT_MAX_VALUE);
            
        end

        status = calllib('ps2000a', 'ps2000aSetSigGenArbitrary', ...
                    deviceObj.DriverData.unitHandle, ...
                    offsetVoltageUV, peakToPeakVoltageUV, startDeltaPhase, ...
                    stopDeltaPhase, deltaPhaseIncrement, dwellCount, arbitraryWave, ...
                    length(arbitraryWave), sweepType, operation, indexMode, shots, ...
                    sweeps, triggerType, triggerSource, extInThreshold);
         
        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)
                    
            switch (status)

                case PicoStatus.PICO_SIG_GEN_PARAM
                    
                    error('setSigGenArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING
                    
                    error('setSigGenArbitrary: Conflict between the shots and sweeps parameters sent to the signal generator.');
                    
                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE
                    
                    error('setSigGenArbitrary: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');
                   
                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT
                    
                    error('setSigGenArbitrary: Attempt to set different EXT input thresholds set for signal generator and oscilloscope trigger.');
                    
                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE
                    
                    error('setSigGenArbitrary: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK
                    
                    error('setSigGenArbitrary: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');
                    
                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED
                    
                    error('setSigGenArbitrary: Unable to setup signal generator waveform.');
                    
                otherwise     
                    
                    error('setSigGenArbitrary:- status code: %d. Please refer to the PicoStatus.m file.', status);
            end
            
        end
        
        clear offsetVoltageUV
        clear peakToPeakVoltageUV
        clear maxBufferSize
        clear arbitraryWave
        clear startDeltaPhase
        clear stopDeltaPhase
        clear dwellCount
        clear deltaPhaseIncrement
        clear dacFrequency;
        clear ddsFrequency;
        clear startFrequency;
        clear stopFrequency;
                
    else
       
        error('AWG functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenArbitrary(obj, increment, dwellTime, arbitraryWaveform, sweepType, operation, indexMode, shots, sweeps, triggerType, triggerSource, extInThresholdMV) programs the signal generator to produce an arbitrary waveform.

The arbitrary waveform generator uses direct digital synthesis (DDS). It maintains a 32-bit phase accumulator that indicates the present location in the waveform. The top bits of the phase accumulator are used as an index into a buffer containing the arbitrary waveform. The remaining bits act as the fractional part of the index, enabling high-resolution control of output frequency and allowing the generation of lower frequencies. The phase accumulator initially increments by a delta phase corresponding to the start frequency. If the AWG is set to sweep mode, the phase increment is increased at specified intervals until it reaches a delta phase corresponding to the stop frequency.

The startFrequency, stopFrequency, offsetVoltage and peakToPeakVoltage properties must be set prior to calling this function, otherwise the current values will be used.

This function may be used with the Test and Measurement Tool.

Input Arguments

obj - the object representing the Signalgenerator group.
increment - the increase or decrease in frequency when operating in sweep mode. This determines the amount by which the generator sweeps the output frequency in each dwell period. When frequency sweeping is not required, set to zero.
dwellTime - the time for which the sweep stays at each frequency, in seconds.
arbitraryWaveform -  a buffer that holds the waveform pattern as a set of samples equally spaced in time in the range -1 to +1. These values correspond to the maximum and minimum amplitude values of the waveform. Each sample is scaled to an output voltage and clipped to the overall ±2 V range of the AWG.
sweepType -  determines whether the startFrequency is swept up to the stopFrequency, or down to it, or repeatedly up and down.
operation - configures the white noise/PRBS (pseudo-random binary sequence) generator.
indexMode - specifies how the signal will be formed from the arbitrary waveform data.
shots - the number of cycles of the waveform to be produced after a trigger event. 

0: sweep the frequency as specified by sweeps
1...PS2000A_MAX_SWEEPS_SHOTS: the number of cycles of the waveform to be
produced after a trigger event. sweeps must be zero. 
PS2000AConstants.PS2000A_SHOT_SWEEP_TRIGGER_CONTINUOUS_RUN: start and run continuously after trigger occurs (not PicoScope 2205 MSO)

sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType.

0: produce number of cycles specified by shots
1..PS2000A_MAX_SWEEPS_SHOTS: the number of times to sweep the frequency after
a trigger event, according to sweepType. shots must be zero.
PS2000A_SHOT_SWEEP_TRIGGER_CONTINUOUS_RUN: start a sweep and continue after
trigger occurs (not PicoScope 2205 MSO)

triggerType - the type of trigger that will be applied to the signal generator (an enPS2000ASigGenTrigType enumeration value).
triggerSource - the source that will trigger the signal generator (an enPS2000ASigGenTrigSource enumeration value).
extInThresholdMV - trigger level, in millivolts, for external trigger. This should be in the range -5000 to 5000 mV. Only used by the PicoScope 2206, 2207 and 2208 models.

Output Arguments:

status - status code returned by the driver.
dwellTime -  the dwell time will be modified if the user specifies a dwell time corresponding to less than the minimum dwell count for the device (10).

AWG index modes:

The arbitrary waveform generator supports single and dual index modes to help you make the best use of the waveform buffer.

Single mode. The generator outputs the raw contents of the buffer repeatedly. This mode is
the only one that can generate asymmetrical waveforms. You can also use this mode for
symmetrical waveforms, but the dual mode makes more efficient use of the
buffer memory.

Dual mode. The generator outputs the contents of the buffer from beginning to end, and then does a second pass in the reverse direction through the buffer. This allows you to specify only the first half of a waveform with twofold symmetry, such as a Gaussian function, and let the generator fill in the other half.

 </Description>
            </Method>
            <Method>
               <Name>setSigGenArbitrarySimple</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenArbitrarySimple(obj, arbitraryWaveform)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Only call function if device has an Arbitrary Waveform Generator
    if (deviceObj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)

        % Convert voltages to microvolts
        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        if (abs(offsetVoltageUV + peakToPeakVoltageUV) &gt; 4000000)
            
            error('setSigGenBuiltInSimple: The sum of offsetVoltage and peakToPeakVoltage cannot exceed +/-4000mV.');
            
        end
        
        maxBufferSize = deviceObj.DriverData.awgBufferSize;
        
        % Convert the waveform to the range for the driver
        arbitraryWave = int16(arbitraryWaveform * double(intmax('int16')));
        
        % Convert frequency to delta phase
        pStartDeltaPhase = libpointer('uint32Ptr', 0);
        indexMode = deviceObj.DriverData.enums.enPS2000AIndexMode.PS2000A_SINGLE;
        
        status = calllib('ps2000a', 'ps2000aSigGenFrequencyToPhase', ...
            deviceObj.DriverData.unitHandle, ...
            deviceObj.DriverData.startFrequency, indexMode, ... 
            length(arbitraryWave), pStartDeltaPhase);
        
        if (status ~= PicoStatus.PICO_OK)
           
            error(['setSigGenArbitrarySimple:- ps2000aSigGenFrequencyToPhase ' ...
                '(frequency) status code: %d. Please refer to the ' ...
                'PicoStatus.m file.'], status);
            
        end
        
        startDeltaPhase = pStartDeltaPhase.Value;

        % Constant frequency
        stopDeltaPhase = startDeltaPhase;
        
        status = calllib('ps2000a', 'ps2000aSetSigGenArbitrary', ...
                    deviceObj.DriverData.unitHandle, offsetVoltageUV, ...
                    peakToPeakVoltageUV, startDeltaPhase, ...
                    stopDeltaPhase, 0, 0, arbitraryWave, ...
                    length(arbitraryWave), 0, 0, 0, 0, 0, 0, 0, 0);
         
        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)
                    
            switch (status)

                case PicoStatus.PICO_SIG_GEN_PARAM
                    
                    error('setSigGenArbitrarySimple: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING
                    
                    error('setSigGenArbitrarySimple: Conflict between the shots and sweeps parameters sent to the signal generator.');
                    
                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE
                    
                    error('setSigGenArbitrarySimple: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');
                   
                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT
                    
                    error('setSigGenArbitrarySimple: Attempt to set different EXT input thresholds set for signal generator and oscilloscope trigger.');
                    
                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE
                    
                    error('setSigGenArbitrarySimple: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK
                    
                    error('setSigGenArbitrarySimple: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');
                    
                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED
                    
                    error('setSigGenArbitrarySimple: Unable to setup signal generator waveform.');
                    
                otherwise     
                    
                    error('setSigGenArbitrarySimple:- status code: %d. Please refer to the PicoStatus.m file.', status);
            end
            
        end
                
    else
       
        error('AWG functionality not supported by this device.');
        
    end


</MCode>
               </Code>
               <Description>setSigGenArbitrary(obj, arbitraryWaveform) programs the signal generator to produce an arbitrary waveform at a constant frequency.

The startFrequency, stopFrequency, offsetVoltage and peakToPeakVoltage properties must be set prior to calling this function, otherwise the current values will be used.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Signalgenerator group.
arbitraryWaveform - a buffer that holds the waveform pattern as a set of samples in the range ±1. These values correspond to the maximum and minimum amplitude values of the waveform.

Output Arguments:

status - status code returned by the driver.
</Description>
            </Method>
            <Method>
               <Name>setSigGenBuiltIn</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenBuiltIn(obj, waveType, increment, dwellTime, sweepType, operation, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
    
    deviceObj = get(obj, 'Parent');
    sigGenType = deviceObj.DriverData.sigGenType;
    
    % Error checking
    if (sigGenType == PicoConstants.SIG_GEN_AWG || ...
            sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN)
        
        % Convert millivolt values to microvolts  
        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        if (abs(offsetVoltageUV + peakToPeakVoltageUV) &gt; 4000000)
            
            error('setSigGenBuiltInSimple: The sum of offsetVoltage and peakToPeakVoltage cannot exceed +/- 4000 mV.');
            
        end
        
        % Convert extInThresholdMV to counts if device is not an MSO model
        if (deviceObj.DriverData.digitalPortCount &gt; 0)        
            
            extInThreshold = 0;
            
        else
            
            extInThreshold = round(((extInThresholdMV / 1000) / ...
                deviceObj.DriverData.constants.PS2000A_EXT_MAX_VOLTAGE) ...
                * deviceObj.DriverData.constants.PS2000A_EXT_MAX_VALUE);
            
        end

        status = calllib('ps2000a', 'ps2000aSetSigGenBuiltIn', deviceObj.DriverData.unitHandle, ...
                    offsetVoltageUV, peakToPeakVoltageUV, waveType, ...
                    deviceObj.DriverData.startFrequency, deviceObj.DriverData.stopFrequency, ...
                    increment, dwellTime, sweepType, operation, shots, sweeps, ...
                    triggerType, triggerSource, extInThreshold);

        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)

            switch (status)

                case PicoStatus.PICO_SIG_GEN_PARAM

                    error('setSigGenBuiltIn: One or more signal generator parameters are out of range.');

                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING

                    error('setSigGenBuiltIn: Conflict between the shots and sweeps parameters sent to the signal generator.');

                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE

                    error('setSigGenBuiltIn: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');

                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE

                    error('setSigGenBuiltIn: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK

                    error('setSigGenBuiltIn: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');

                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED

                    error('setSigGenBuiltIn: Unable to setup signal generator waveform.');

                otherwise     

                    error('setSigGenBuiltIn: status code: %d. Please refer to the PicoStatus.m file.', status);
            end

        end
        
        clear offsetVoltage;
        clear peakToPeakVoltage;
        clear sigGenType;
            
    else
        
        error('setSigGenBuiltIn: Signal Generator functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenBuiltIn(obj, waveType, increment, dwellTime, sweepType, operation, shots, sweeps, triggerType, triggerSource, extInThresholdMV) sets up the signal generator to produce a signal from a list of built-in waveforms. If different start and stop frequencies are specified, the device will sweep
either up, down, or up and down.

The startFrequency, stopFrequency, offsetVoltage and peakToPeakVoltage properties must be set prior to calling this function otherwise the current values will be used.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Signalgenerator group.
wavetype - the type of waveform to be generated by the oscilloscope. Use one of the enPS2000AWaveType enumeration values.
increment - the amount of frequency increase or decrease in sweep mode (in hertz).
dwellTime - the time for which the sweep stays at each frequency, in seconds. 
sweepType - whether the frequency will sweep from startFrequency to stopFrequency, or in the opposite direction, or repeatedly reverse direction. Use one of the enPS2000ASweepType enumeration values.
operation - the type of waveform to be produced, specified by one of the enPS2000AExtraOperations enumeration values.
shots - the number of cycles of the waveform to be produced after a trigger event. If this is set to a non-zero value then sweeps must be set to zero:

0: sweep the frequency as specified by sweeps
1...PS2000A_MAX_SWEEPS_SHOTS: the number of cycles of the waveform to be
produced after a trigger event. sweeps must be zero. PS2000A_SHOT_SWEEP_TRIGGER_CONTINUOUS_RUN: start and run continuously after
trigger occurs (not PicoScope 2205 MSO)

sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType. If this is set to a non-zero value then shots must be set to zero:

0: produce number of cycles specified by shots
1..PS2000A_MAX_SWEEPS_SHOTS: the number of times to sweep the frequency after
a trigger event, according to sweepType. shots must be zero.
PS2000A_SHOT_SWEEP_TRIGGER_CONTINUOUS_RUN: start a sweep and continue after
trigger occurs (not PicoScope 2205 MSO)

triggerType - the type of trigger that will be applied to the signal generator, specified by one of the enPS2000ASigGenTrigType enumeration values.
triggerSource - the source that will trigger the signal generator, specified by one of the enPS2000ASigGenTrigSource enumeration values.
extInThresholdMV - trigger level, in millivolts, for external trigger. This should be in the range -5000 to 5000mV. Only used by the PicoScope 2206, 2207 and 2208 models.

Output Arguments:

status - status code returned by the driver.

</Description>
            </Method>
            <Method>
               <Name>setSigGenBuiltInSimple</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenBuiltInSimple(obj, waveType)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
 
    deviceObj = get(obj, 'Parent');
    sigGenType = deviceObj.DriverData.sigGenType;
    
    % Error checking
    if (sigGenType == PicoConstants.SIG_GEN_AWG || ...
            sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN)
        
        % Convert millivolt values to microvolts  
        offsetVoltageUV = deviceObj.DriverData.offsetVoltage * 1e3;
        peakToPeakVoltageUV = deviceObj.DriverData.peakToPeakVoltage * 1e3;
        
        if (abs(offsetVoltageUV + peakToPeakVoltageUV) &gt; 4000000)
            
            error('setSigGenBuiltInSimple: The sum of offsetVoltage and peakToPeakVoltage cannot exceed +/- 4000 mV.');
            
        end
        
        status = calllib('ps2000a', 'ps2000aSetSigGenBuiltIn', deviceObj.DriverData.unitHandle, ...
                    offsetVoltageUV, peakToPeakVoltageUV, waveType, ...
                    deviceObj.DriverData.startFrequency, deviceObj.DriverData.startFrequency, ...
                        0, 0, 0, 0, 0, 0, 0, 0, 0);
                    
        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)

            switch status

                case PicoStatus.PICO_SIG_GEN_PARAM

                    error('setSigGenBuiltInSimple: One or more signal generator parameters are out of range.');

                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING

                    error('setSigGenBuiltInSimple: Conflict between the shots and sweeps parameters sent to the signal generator.');

                case PicoStatus.PICO_SIGGEN_OUTPUT_OVER_VOLTAGE

                    error('setSigGenBuiltInSimple: The combined peak to peak voltage and the analog offset voltage must be in the range 0 -&gt; +/- 2V');

                case PicoStatus.PICO_WARNING_EXT_THRESHOLD_CONFLICT

                    error('setSigGenBuiltInSimple: External threshold conflict.');

                case PicoStatus.PICO_SIGGEN_OFFSET_VOLTAGE

                    error('setSigGenBuiltInSimple: The analog offset voltage is out of range.');

                case PicoStatus.PICO_SIGGEN_PK_TO_PK

                    error('setSigGenBuiltInSimple: The analog peak to peak voltage must be in the range 0 -&gt; +/- 2V.');

                case PicoStatus.PICO_SIGGEN_WAVEFORM_SETUP_FAILED

                    error('setSigGenBuiltInSimple: Unable to setup signal generator waveform.');

                otherwise     

                    error('setSigGenBuiltInSimple:- status code: %d. Please refer to the PicoStatus.m file.', status);
            end

        end  
        
        clear offsetVoltageUV;
        clear peakToPeakVoltageUV;
        clear sigGenType;
    
    else
        
        error('setSigGenBuiltInSimple: Signal Generator functionality not supported by this device.');
        
    end
</MCode>
               </Code>
               <Description>setSigGenBuiltInSimple(obj, waveType) sets up the signal generator to produce a signal of constant frequency from a list of built-in waveforms.

The startFrequency, offsetVoltage and peakToPeakVoltage properties must be set prior to using this function, or the current values will be used.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Signalgenerator group.
wavetype - the type of waveform to be generated by the oscilloscope. Use one of the enPS2000AWaveType enumeration values.

Output Arguments:

status - status code returned by the driver.

For further information, please view the Help text for the setSigGenBuiltIn function.
</Description>
            </Method>
            <Method>
               <Name>setSigGenOff</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenOff(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    offsetVoltage = 0;
    pkToPk = 0;
    waveTypeDC = deviceObj.DriverData.enums.enPS2000AWaveType.PS2000A_DC_VOLTAGE;
    
    status = calllib('ps2000a', 'ps2000aSetSigGenBuiltIn', ...
                deviceObj.DriverData.unitHandle, ...
                offsetVoltage, pkToPk, waveTypeDC, 0, 0, ...
                0, 0, 0, 0, 0, 0, 0, 0, 0);
                    
    if (status ~= PicoStatus.PICO_OK)
       
        error('setSigGenOff:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end
            
	clear offsetVoltage;
    clear pkToPk;
    clear waveTypeDC;</MCode>
               </Code>
               <Description>setSigGenOff(obj) effectively turns off the signal generator by setting the output to a zero DC voltage.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Signalgenerator group.

Output Arguments:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>setSigGenPropertiesArbitrary</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, dwellTime] = setSigGenPropertiesArbitrary(obj, increment, dwellTime, sweepType, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Only call function if device has an Arbitrary Waveform Generator
    if (deviceObj.DriverData.sigGenType == PicoConstants.SIG_GEN_AWG)
        
        maxBufferSize = deviceObj.DriverData.awgBufferSize;
        dacFrequency = deviceObj.DriverData.dacFrequency;
        ddsFrequency = deviceObj.DriverData.ddsFrequency;
        
        % Convert the waveform to the range for the driver
        arbitraryWave = int16(arbitraryWaveform * double(intmax('int16')));
        
        startFrequency = deviceObj.DriverData.startFrequency;

        % Convert start frequency to delta phase value
        pStartDeltaPhase = libpointer('uint32Ptr', 0);
        
        status = calllib('ps2000a', 'ps2000aSigGenFrequencyToPhase', ...
            deviceObj.DriverData.unitHandle, ...
            deviceObj.DriverData.startFrequency, indexMode, ... 
            length(arbitraryWave), pStartDeltaPhase);
        
        if (status ~= PicoStatus.PICO_OK)
           
            error(['setSigGenPropertiesArbitrary:- ps2000aSigGenFrequencyToPhase ' ...
                '(start freq.) status code: %d. Please refer to the ' ...
                'PicoStatus.m file.'], status);
            
        end
        
        startDeltaPhase = pStartDeltaPhase.Value;

        stopDeltaPhase = 0;
        dwellCount = 0;

        % No need to calculate stop delta phase if start and stop frequencies
        % are the same.
        
        stopFrequency = deviceObj.DriverData.stopFrequency;
        
        if (stopFrequency == startFrequency)

            stopDeltaPhase = startDeltaPhase;

        else

             % Convert stop frequency to delta phase
            pStopDeltaPhase = libpointer('uint32Ptr', 0);

            status = calllib('ps2000a', 'ps2000aSigGenFrequencyToPhase', ...
                deviceObj.DriverData.unitHandle, ...
                deviceObj.DriverData.stopFrequency, indexMode, ... 
                length(arbitraryWave), pStopDeltaPhase);
            
            error(['setSigGenPropertiesArbitrary:- ps2000aSigGenFrequencyToPhase ' ...
                '(stop freq.) status code: %d. Please refer to the ' ...
                'PicoStatus.m file.'], status);

            stopDeltaPhase = pStopDeltaPhase.Value;

        end
        
        % Convert start frequency to delta phase value
        pDeltaPhaseIncrement = libpointer('uint32Ptr', 0);
        
        status = calllib('ps2000a', 'ps2000aSigGenFrequencyToPhase', ...
            deviceObj.DriverData.unitHandle, ...
            deviceObj.DriverData.startFrequency, indexMode, ... 
            length(arbitraryWave), pDeltaPhaseIncrement);
        
        if(status ~= PicoStatus.PICO_OK)
           
            error(['setSigGenPropertiesArbitrary:- ps2000aSigGenFrequencyToPhase ' ...
                '(increment freq.) status code: %d. Please refer to the ' ...
                'PicoStatus.m file.'], status);
            
        end
        
        deltaPhaseIncrement = pDeltaPhaseIncrement.Value;
            
        % Round to the nearest integer
        if (strcmp(deviceObj.InstrumentModel, deviceObj.DriverData.variants.MODEL_PS2205MSO))
            
            dwellCount = round(dwellTime * ddsFrequency);
        
        else
            
            dwellCount = round(dwellTime * dacFrequency); % Round to the nearest integer
            
        end
        
        if(dwellCount &lt; obj.DriverData.constants.PS2000A_MIN_DWELL_COUNT)

            dwellCount = obj.DriverData.constants.PS2000A_MIN_DWELL_COUNT;

        end
        
        % Return dwell time information to the user if it has been
        % modified.
        if (strcmp(deviceObj.InstrumentModel, deviceObj.DriverData.variants.MODEL_PS2205MSO))
            
            dwellTime = dwellCount / ddsFrequency;
            
        else
            
            dwellTime = dwellCount / dacFrequency;
            
        end

        % Convert extInThresholdMV to counts if device is not an MSO model
        if (deviceObj.DriverData.digitalPortCount &gt; 0)        
            
            extInThreshold = 0;
            
        else
            
            extInThreshold = round(((extInThresholdMV / 1000) / ...
                deviceObj.DriverData.constants.PS2000A_EXT_MAX_VOLTAGE) ...
                * deviceObj.DriverData.constants.PS2000A_EXT_MAX_VALUE);
            
        end

        status = calllib('ps2000a', 'ps2000aSetSigGenPropertiesArbitrary', ...
                    deviceObj.DriverData.unitHandle, startDeltaPhase, ...
                    stopDeltaPhase, deltaPhaseIncrement, dwellCount, ...
                    sweepType, shots, sweeps, triggerType, triggerSource, ...
                    extInThreshold);
         
        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)
                    
            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM
                    
                    error('setSigGenPropertiesArbitrary: Incorrect parameter passed to the signal generator.');
                    
                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING
                    
                    error('setSigGenPropertiesArbitrary: Conflict between the shots and sweeps parameters sent to the signal generator.');
                    
                otherwise     
                    
                    error('setSigGenPropertiesArbitrary:- status code: %d. Please refer to the PS4000 Series (A API) Programmer''s Guide.\n', status);
            end
            
        end

        clear maxBufferSize
        clear dacFrequency
        clear ddsFrequency
        clear startDeltaPhase
        clear stopDeltaPhase
        clear dwellCount
        clear deltaPhaseIncrement
        clear startFrequency;
        clear stopFrequency;
                
    else
       
        error('AWG functionality not supported by this device.');
        
    end</MCode>
               </Code>
               <Description>setSigGenPropertiesArbitrary(obj, increment, dwellTime, sweepType, shots, sweeps, triggerType, triggerSource, extInThresholdMV) reprograms the arbitrary waveform generator. 

All values can be reprogrammed while the signal generator is waiting for a trigger. The startFrequency and stopFrequency properties should be set if they require changing before calling this function otherwise the current values will be used.

The setSigGenArbitrary function must be called prior to calling this function.

This function may be used with the Test and Measurement Tool.

Input parameters:

obj - the object representing the Signalgenerator group.
increment - the increase or decrease in frequency when operating in sweep mode. This determines the amount by which the generator sweeps the output frequency in each dwell period. When frequency sweeping is not required, set to zero.
dwellTime - the time for which the sweep stays at each frequency, in seconds.
sweepType -  determines whether the startFrequency is swept up to the stopFrequency, or down to it, or repeatedly up and down.
shots - the number of cycles of the waveform to be produced after a trigger event. 
sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType.
triggerType - the type of trigger that will be applied to the signal generator (an enPS2000ASigGenTrigType enumeration value).
triggerSource - the source that will trigger the signal generator (an enPS2000ASigGenTrigSource enumeration value).
extInThresholdMV - trigger level, in millivolts, for external trigger. This should be in the range -5000 to 5000 mV. Only used by the PicoScope 2206, 2207 and 2208 models.

Output parameters:

status - status code returned by the driver.
dwellTime -  the dwell time will be modified if the user specifies a dwell time (125e-9) corresponding to less than the minimum dwell count for the device (10).

Please also refer to the setSigGenPropertiesArbitrary function description in the PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.





</Description>
            </Method>
            <Method>
               <Name>setSigGenPropertiesBuiltIn</Name>
               <Location>signalgenerator</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSigGenPropertiesBuiltIn(obj, increment, dwellTime, sweepType, shots, sweeps, triggerType, triggerSource, extInThresholdMV)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    sigGenType = deviceObj.DriverData.sigGenType;
    
    % Error checking
    if (sigGenType == PicoConstants.SIG_GEN_AWG || ...
            sigGenType == PicoConstants.SIG_GEN_FUNCT_GEN)
        
        % Convert extInThresholdMV to counts if device is not an MSO model
        if (obj.DriverData.digitalPortCount &gt; 0)        
            
            extInThreshold = 0;
            
        else
            
            extInThreshold = round(((extInThresholdMV / 1000) / ...
                deviceObj.DriverData.constants.PS2000A_EXT_MAX_VOLTAGE) ...
                * deviceObj.DriverData.constants.PS2000A_EXT_MAX_VALUE);
            
        end

        status = calllib('ps2000a', 'ps2000aSetSigGenPropertiesBuiltIn', ...
                    deviceObj.DriverData.unitHandle, ...
                    deviceObj.DriverData.startFrequency, ... 
                    deviceObj.DriverData.stopFrequency, ...
                    increment, dwellTime, sweepType, shots, sweeps, ...
                    triggerType, triggerSource, extInThreshold);

        % Output error message to user if status is not PICO_OK        
        if (status ~= PicoStatus.PICO_OK)

            switch(status)

                case PicoStatus.PICO_SIG_GEN_PARAM

                    error('setSigGenPropertiesBuiltIn: One or more signal generator parameters are out of range.');

                case PicoStatus.PICO_SHOTS_SWEEPS_WARNING

                    error('setSigGenPropertiesBuiltIn: Conflict between the shots and sweeps parameters sent to the signal generator.');

                otherwise     

                    error('setSigGenPropertiesBuiltIn:- Status code: %d. Please refer to the PicoStatus.m file.\n', status);
            end

        end
        
        clear sigGenType;
            
    else
        
        error('setSigGenPropertiesBuiltIn: Signal Generator functionality not supported by this device.');
        
    end
    </MCode>
               </Code>
               <Description>setSigGenPropertiesBuiltIn(obj, increment, dwellTime, sweepType, shots, sweeps, triggerType, triggerSource, extInThresholdMV) reprograms the signal generator. Values can be changed while the signal generator is waiting for a trigger.

The startFrequency, stopFrequency properties must be set prior to calling this function or the current values will be used.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Signalgenerator group.
increment - the amount of frequency increase or decrease in sweep mode (in hertz).
dwellTime - the time for which the sweep stays at each frequency, in seconds. 
sweepType - whether the frequency will sweep from startFrequency to stopFrequency, or in the opposite direction, or repeatedly reverse direction. Use one of the enPS2000ASweepType enumeration values.
shots - the number of cycles of the waveform to be produced after a trigger event. If this is set to a non-zero value then sweeps must be set to zero.
sweeps - the number of times to sweep the frequency after a trigger event, according to sweepType. If this is set to a non-zero value then shots must be set to zero.
triggerType - the type of trigger that will be applied to the signal generator, specified by one of the enPS2000ASigGenTrigType enumeration values.
triggerSource - the source that will trigger the signal generator, specified by one of the enPS2000ASigGenTrigSource enumeration values.
extInThresholdMV - trigger level, in millivolts, for external trigger. This should be in the range +/- 5000 mV. Only used by the PicoScope 2206, 2207 and 2208 models.

Output Arguments:

status - status code returned by the driver.

Please also refer to the setSigGenBuiltIn function description in the PicoScope 2000 Series (A API) - MATLAB Generic Instrument Driver Toolbox Help Documentation.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>streaming</Name>
         <Description>The Streaming group contains a set of properties and functions related to the streaming mode capture functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="streaming" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>autoStop</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.autoStop;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.autoStop = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>1.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>A flag to specify if streaming data collection should stop when the sum of pre-trigger and post-trigger samples have been taken.

This flag should be set to 0 or 1.</Description>
            </Property>
            <Property>
               <Name>streamingInterval</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.streamingInterval;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.streamingInterval = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The streaming mode sample interval to be used (in seconds).</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>autoStopped</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function autoStop = autoStopped(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    autoStop = calllib('ps2000aWrap', 'AutoStopped', ...
        deviceObj.DriverData.unitHandle);</MCode>
               </Code>
               <Description>autoStopped(obj) indicates if the device has stopped on collection of the number of samples specified in the call to the ps2000aRunStreaming function.

The autoStop property must have been set to 1.

Input Arguments:

obj - the object representing the Streaming group.

Output Arguments:

autoStop - 0 if the device has not stopped, non-zero if streaming has auto-stopped.</Description>
            </Method>
            <Method>
               <Name>availableData</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [numSamples, startIndex] = availableData(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    startIndex = 0; % Initialise variable to be used as a pointer

    [numSamples, startIndex] = calllib('ps2000aWrap', 'AvailableData', ...
                                deviceObj.DriverData.unitHandle, startIndex);</MCode>
               </Code>
               <Description>availableData(obj) indicates the number of samples returned from the driver and shows the start index of the data in the buffer when collecting data in streaming mode.

Input Arguments:

obj - the object representing the Streaming group.

Output Arguments:

numSamples - 0, data is not yet available; Non-zero, the number of samples returned from the driver.
startIndex - an index to the first valid sample in the buffer (when data is available).

Note: the startIndex value is zero-based so should be incremented by 1 when used to retrieve data from the buffer.</Description>
            </Method>
            <Method>
               <Name>clearTriggerReady</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function triggerCleared = clearTriggerReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    triggerCleared = calllib('ps2000aWrap', 'ClearTriggerReady', ...
        deviceObj.DriverData.unitHandle);</MCode>
               </Code>
               <Description>clearTriggerReady(obj) clears the triggered and triggeredAt flags in relation to streaming mode capture.

Input Arguments:

obj - the object representing the Streaming group.

Output Arguments:

1 - Function successfully completed.</Description>
            </Method>
            <Method>
               <Name>getStreamingLatestValues</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = getStreamingLatestValues(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    status = calllib('ps2000aWrap', 'GetStreamingLatestValues', ...
                deviceObj.DriverData.unitHandle);
            
    if(status ~= PicoStatus.PICO_OK &amp;&amp; status ~= PicoStatus.PICO_BUSY)
           
        error('ps2000aGetStreamingLatestValues:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end</MCode>
               </Code>
               <Description>getStreamingLatestValues(obj) facilitates communication with the underlying driver to return the next block of values to your application when capturing data in streaming mode.

Input Arguments:

obj - the object representing the Streaming group.

Output Arguments:

status - status code returned by the driver.
</Description>
            </Method>
            <Method>
               <Name>isReady</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function ready = isReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    ready = calllib('ps2000aWrap', 'IsReady', deviceObj.DriverData.unitHandle);
</MCode>
               </Code>
               <Description>isReady(obj) is used to poll the driver to verify that data is ready to be received. The ps2000aRunStreaming function must have been called prior to calling this function.

Input Arguments:

obj - the object representing the Streaming group.

Output Arguments:

ready - 0, if data is not yet available; non-zero if data is ready to be collected.</Description>
            </Method>
            <Method>
               <Name>isTriggerReady</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [triggered, triggeredAt] = isTriggerReady(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    triggeredAt = 0; % Initialise value to zero for pointer.

    [triggered, triggeredAt] = calllib('ps2000aWrap', 'IsTriggerReady', ...
        deviceObj.DriverData.unitHandle, triggeredAt);
</MCode>
               </Code>
               <Description>isTriggerReady(obj) indicates whether a trigger has occurred when collecting data in streaming mode, and the location of the trigger point.

Input Arguments:

obj - the object representing the Streaming group.

Output Arguments:

triggered - 0, if the device has not triggered; Non-zero, if the device has been triggered.
triggeredAt - the zero-based index of the sample in the buffer relative to the start index (see availableData) where the trigger occurred.</Description>
            </Method>
            <Method>
               <Name>ps2000aNoOfStreamingValues</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, noOfValues] = ps2000aNoOfStreamingValues(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    noOfValues = 0; % Initialise value for use as pointer.

    [status, noOfValues] = calllib('ps2000a', 'ps2000aNoOfStreamingValues', ...
        unitHandle, noOfValues);
    
    if(status ~= PicoStatus.PICO_OK)
           
        error('ps2000aNoOfStreamingValues:- status code: %d. Please refer to the PicoStatus.m file.', status); 
        
    end
</MCode>
               </Code>
               <Description>ps2000aNoOfStreamingValues(obj) returns the number of samples available after data collection in streaming mode. Call this function after calling ps2000aStop.

Input Aguments:

obj - the object representing the device.

Output Arguments:

status - status code returned by the driver.
noOfValues - the number of samples.</Description>
            </Method>
            <Method>
               <Name>ps2000aRunStreaming</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, sampleInterval, sampleIntervalTimeUnitsStr] = ps2000aRunStreaming(obj, downSampleRatio, downSampleRatioMode, overviewBufferSize)


    deviceObj = get(obj, 'Parent');
    unitHandle = deviceObj.DriverData.unitHandle;
    
    % Calculate sampleInterval and sampleIntervalTimeUnits according to
    % streamingInterval property set. Property is defined in seconds.

    streamingInterval = deviceObj.DriverData.streamingInterval;
    
    femtosecondsEnum    = deviceObj.DriverData.enums.enPS2000ATimeUnits.PS2000A_FS;
    picosecondsEnum     = deviceObj.DriverData.enums.enPS2000ATimeUnits.PS2000A_PS;
    nanosecondsEnum     = deviceObj.DriverData.enums.enPS2000ATimeUnits.PS2000A_NS;
    microsecondsEnum    = deviceObj.DriverData.enums.enPS2000ATimeUnits.PS2000A_US;
    millisecondsEnum    = deviceObj.DriverData.enums.enPS2000ATimeUnits.PS2000A_MS;
    secondsEnum         = deviceObj.DriverData.enums.enPS2000ATimeUnits.PS2000A_S;
    
    sampleIntervalTimeUnits = secondsEnum;
    
    % Match the specified interval to the correct time units
    % If an interval with component less than the minimum value for the time unit 
    % is specified e.g 1.3e-3, that will be converted to 1300 microseconds.
    
    if (streamingInterval &lt; 1e-12) % Femtoseconds (unlikely with USB 2.0/USB 3.0)
        
        sampleInterval = streamingInterval * 1e15;
        sampleIntervalTimeUnits = femtosecondsEnum;
        
    elseif (streamingInterval &gt;= 1e-12 &amp;&amp; streamingInterval &lt; 1e-9) % Picoseconds
        
        if (mod(streamingInterval, 1e-12) &gt; 0)
        
            sampleInterval = streamingInterval * 1e15;
            sampleIntervalTimeUnits = femtosecondsEnum;
            
        else
           
            sampleInterval = streamingInterval * 1e12;
            sampleIntervalTimeUnits = picosecondsEnum;
            
        end
        
    elseif (streamingInterval &gt;= 1e-9 &amp;&amp; streamingInterval &lt; 1e-6) % Nanoseconds

        if (mod(streamingInterval, 1e-9) &gt; 0)
            
            sampleInterval = streamingInterval * 1e12;
            sampleIntervalTimeUnits = picosecondsEnum;
            
        else
           
            sampleInterval = streamingInterval * 1e9;
            sampleIntervalTimeUnits = nanosecondsEnum;
            
        end
        
    elseif (streamingInterval &gt;= 1e-6 &amp;&amp; streamingInterval &lt; 1e-3) % Microseconds
        
        if (mod(streamingInterval, 1e-6) &gt; 0)
        
            sampleInterval = streamingInterval * 1e9;
            sampleIntervalTimeUnits = nanosecondsEnum;
            
        else
           
            sampleInterval = streamingInterval * 1e6;
            sampleIntervalTimeUnits = microsecondsEnum;
            
        end
        
    elseif (streamingInterval &gt;= 1e-3 &amp;&amp; streamingInterval &lt; 1) % Milliseconds
        
        if (mod(streamingInterval, 1e-3) &gt; 0)
           
            sampleInterval = streamingInterval * 1e6;
            sampleIntervalTimeUnits = microsecondsEnum;
            
        else
            
            sampleInterval = streamingInterval * 1e3;
            sampleIntervalTimeUnits = millisecondsEnum;
            
        end
            
    else 
        
        % Already defined seconds 
        
        % 
        if (mod(sampleInterval, 1) &gt; 0)
           
           sampleInterval = streamingInterval * 1e3;
           sampleIntervalTimeUnits = millisecondsEnum;
           
       end
        
    end
    
    [status, sampleInterval] = calllib('ps2000a', 'ps2000aRunStreaming', ...
        unitHandle, sampleInterval, sampleIntervalTimeUnits, ...
        deviceObj.DriverData.numPreTriggerSamples, ...
        deviceObj.DriverData.numPostTriggerSamples, ...
        deviceObj.DriverData.autoStop, downSampleRatio, ...
        downSampleRatioMode, overviewBufferSize);
    
    if (status == PicoStatus.PICO_OK)
          
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('ps2000aRunStreaming:- sample interval %d', sampleInterval);
            
        end
        
        switch(sampleIntervalTimeUnits)
       
            case femtosecondsEnum

                sampleIntervalTimeUnitsStr = 'fs';
                
            case picosecondsEnum

                sampleIntervalTimeUnitsStr = 'ps';

            case nanosecondsEnum

                sampleIntervalTimeUnitsStr = 'ns';

            case microsecondsEnum

                sampleIntervalTimeUnitsStr = 'us';

            case millisecondsEnum

                sampleIntervalTimeUnitsStr = 'ms';

            case secondsEnum

                sampleIntervalTimeUnitsStr = 's';
            
            otherwise
                
                % Do nothing
        
        end
        
        if (deviceObj.DriverData.displayOutput == PicoConstants.TRUE)
            
            fprintf('%s\n', sampleIntervalTimeUnitsStr);
            
        end
        
        clear streamingInterval;
        clear femtosecondsEnum;
        clear picosecondsEnum;
        clear nanosecondsEnum;
        clear microsecondsEnum;
        clear millisecondsEnum;
        clear secondsEnum;      
        
    end
</MCode>
               </Code>
               <Description>ps2000aRunStreaming(obj, downSampleRatio, downSampleRatioMode, overviewBufferSize) tells the oscilloscope to start collecting data in streaming mode. Use the function getStreamingLatestValues to ensure values are copied into the application buffers. 

Input Arguments:

obj - the object representing the Streaming group.
downSampleRatio - the downsampling factor that will be applied to the raw data.
downSampleRatioMode -  which downsampling mode to use (an enumeration from the enPS2000ARatioMode range).
overviewBufferSize - the size of the overview buffers (temporary buffers used for storing the data before returning it to the application).

Output parameters:

status - status code returned by the driver.
sampleInterval - the actual time interval used.
sampleIntervalTimeUnitsStr - a string representing the time unit for the sampling interval.
</Description>
            </Method>
            <Method>
               <Name>setAppAndDriverBuffers</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setAppAndDriverBuffers(obj, channel, appBuffer, driverBuffer, bufferLength)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    status = calllib('ps2000aWrap', 'setAppAndDriverBuffers', ...
        deviceObj.DriverData.unitHandle, channel, appBuffer, driverBuffer, bufferLength);
    
    if(status ~= PicoStatus.PICO_OK)
       
        if (status == PicoStatus.PICO_INVALID_CHANNEL)
            
            error('setAppAndDriverBuffers: Invalid channel specified.');
                    
        elseif (status == PicoStatus.PICO_INVALID_HANDLE)
            
            error('setAppAndDriverBuffers: Invalid handle specified.');
            
        else
            
            error ('setAppAndDriverBuffers:- status code %d - please refer to the PicoStatus.m file.\n', status);
        
        end
        
    end</MCode>
               </Code>
               <Description>setAppAndDriverBuffers(obj, channel, appBuffer, driverBuffer, bufferLength) set the application and corresponding driver buffer in the wrapper shared library for an analog input channel.

This function is required to allow the driver to copy the data into the application buffer being used in MATLAB when acquiring data from the PicoScope in streaming mode without aggregation.

Input Arguments:

obj - the object representing the Streaming group.
channel - the analog channel to which the buffer corresponds (an enumeration from the enPS2000AChannel range).
appBuffer - a libpointer object corresponding to a 1-D array of 16-bit integer values representing the application buffer.
driverBuffer - the libpointer object passed to the driver in the |ps2000aSetDataBuffer| function call for this channel.
bufferLength - the length of the arrays represented by the libpointer objects (must be equal).

Output Arguments:

status - status code returned by the wrapper driver.</Description>
            </Method>
            <Method>
               <Name>setAppAndDriverDigiBuffers</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setAppAndDriverDigiBuffers(obj, port, appDigiBuffer, driverDigiBuffer, bufferLength)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    status = calllib('ps2000aWrap', 'setAppAndDriverDigiBuffers', ...
        deviceObj.DriverData.unitHandle, port, appDigiBuffer, driverDigiBuffer, bufferLength);
    
    if (status ~= PicoStatus.PICO_OK)
       
        if (status == PicoStatus.PICO_INVALID_CHANNEL)
            
            error('setAppAndDriverDigiBuffers: Invalid channel specified.');
                    
        elseif (status == PicoStatus.PICO_INVALID_HANDLE)
            
            error('setAppAndDriverBuffers: Invalid handle specified.');
            
        else
            
            error('setAppAndDriverDigiBuffers:- status code %d - please refer to the PicoStatus.m file.\n', status);
        
        end
        
    end</MCode>
               </Code>
               <Description>setAppAndDriverDigiBuffers(obj, port, appBuffer, driverBuffer, bufferLength) set the application and corresponding driver buffer for a digital port in the wrapper driver.

This function is required to allow the driver to copy the data for a digital port into the corresponding application buffer being used in MATLAB when acquiring data from the PicoScope in streaming mode without aggregation.

Input Arguments:

obj - the object representing the Streaming group.
port - the port to which the buffer corresponds (an enumeration from the enPS2000AWrapDigitalPortIndex range).
appDigiBuffer - a libpointer object corresponding to a 1-D array of 16-bit integer values representing the application buffer.
driverDigiBuffer - the libpointer object passed to the driver in the ps2000aSetDataBuffer function call.
bufferLength - the length of the arrays represented by the libpointer objects (must be equal).

Output Arguments:

status - status code returned by the wrapper driver.

</Description>
            </Method>
            <Method>
               <Name>setMaxMinAppAndDriverBuffers</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setMaxMinAppAndDriverBuffers(obj, channel, appMaxBuffer, appMinBuffer, driverMaxBuffer, driverMinBuffer, bufferLength)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
    
    deviceObj = get(obj, 'Parent');
    
    status = calllib('ps2000aWrap', 'setMaxMinAppAndDriverBuffers', ...
        deviceObj.DriverData.unitHandle, channel, appMaxBuffer, appMinBuffer, ...
        driverMaxBuffer, driverMinBuffer, bufferLength);
    
    if (status ~= PicoStatus.PICO_OK)
       
        if (status == PicoStatus.PICO_INVALID_CHANNEL)
            
            error('setAppAndDriverBuffers: Invalid channel specified.');
                    
        elseif (status == PicoStatus.PICO_INVALID_HANDLE)
            
            error('setMaxMinAppAndDriverBuffers: Invalid handle specified.');
            
        else
            
            error('setMaxMinAppAndDriverBuffers:- status code %d - please refer to the PicoStatus.m file.\n', status);
        
        end
        
    end</MCode>
               </Code>
               <Description>setMaxMinAppAndDriverBuffers(obj, channel, appMaxBuffer, appMinBuffer, driverMaxBuffer, driverMinBuffer, bufferLength) set the maximum and minimum application and corresponding driver buffers for an analog input channel in the wrapper driver.

This function is required to allow the driver to copy the data into the maximum and minimum application buffers being used in MATLAB when acquiring data from the PicoScope in streaming mode with aggregation.

Input Arguments:

obj - the object representing the Streaming group.
channel - the channel to which the buffers correspond (an enumeration from the enPS2000AChannel range).
appMaxBuffer - a libpointer object corresponding to a 1-D array of 16-bit integer values to hold the maximum aggregated data values.
appMinBuffer - a libpointer object corresponding to a 1-D array of 16-bit integer values to hold the minimum aggregated data values.
driverMaxBuffer - the libpointer object passed to the driver for the maximum aggregated data values  in the ps2000aSetDataBuffers function call.
driverMinBuffer - the libpointer object passed to the driver for the minimum aggregated data values in the ps2000aSetDataBuffers function call.
bufferLength -  the length of the arrays represented by the libpointer objects (must be equal).

Output Arguments:

status - status code returned by the wrapper driver.

</Description>
            </Method>
            <Method>
               <Name>setMaxMinAppAndDriverDigiBuffers</Name>
               <Location>streaming</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setMaxMinAppAndDriverDigiBuffers(obj, channel, appDigiMaxBuffer, appDigiMinBuffer, driverDigiMaxBuffer, driverDigiMinBuffer, bufferLength)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.
    
    deviceObj = get(obj, 'Parent');
    
    status = calllib('ps2000aWrap', 'setMaxMinAppAndDriverDigiBuffers', ...
        deviceObj.DriverData.unitHandle, channel, appDigiMaxBuffer, appDigiMinBuffer, ...
        driverDigiMaxBuffer, driverDigiMinBuffer, bufferLength);
    
    if (status ~= PicoStatus.PICO_OK)
       
        if (status == PicoStatus.PICO_INVALID_CHANNEL)
            
            error('setAppAndDriverBuffers: Invalid channel specified.');
                    
        elseif (status == PicoStatus.PICO_INVALID_HANDLE)
            
            error('setMaxMinAppAndDriverDigiBuffers: Invalid handle specified.');
            
        else
            
            error('setMaxMinAppAndDriverDigiBuffers:- status code %d - please refer to the PicoStatus.m file.\n', status);
        
        end
        
    end</MCode>
               </Code>
               <Description>setMaxMinAppAndDriverDigiBuffers(obj, port, appDigiMaxBuffer, appDigiMinBuffer, driverDigiMaxBuffer, driverDigiMinBuffer, bufferLength) set the maximum and minimum application and corresponding driver buffers for a digital port in the wrapper driver.

This function is required to allow the driver to copy the data into the maximum and minimum application buffers being used in MATLAB when acquiring data from the PicoScope in streaming mode with aggregation.

Input Arguments:

obj - the object representing the Streaming group.
port - the port to which the buffer corresponds (an enumeration from the enPS2000AWrapDigitalPortIndex range).
appDigiMaxBuffer - a libpointer object corresponding to a 1-D array of 16-bit integer values to hold the maximum aggregated data values.
appDigiMinBuffer - a libpointer object corresponding to a 1-D array of 16-bit integer values to hold the minimum aggregated data values.
driverDigiMaxBuffer - the libpointer object passed to the driver for the maximum aggregated data values in the ps2000aSetDataBuffers function call.
driverDigiMinBuffer - the libpointer object passed to the driver for the minimum aggregated data values in the ps2000aSetDataBuffers function call.
bufferLength - the length of the arrays (must be equal)

Output Arguments:

status - status code returned by the wrapper driver.
</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>trigger</Name>
         <Description>The Trigger group contains a set of properties and functions related to the trigger functionality of the device.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="trigger" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>autoTriggerMs</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent'); 
    propertyValue = deviceObj.DriverData.autoTriggerMs;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.autoTriggerMs = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The number of milliseconds the device will wait if no trigger occurs. If this is set to zero, the scope device will wait indefinitely for a trigger.
</Description>
            </Property>
            <Property>
               <Name>delay</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    propertyValue = deviceObj.DriverData.delay;</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    deviceObj.DriverData.delay = propertyValue;</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>The time, in sample periods, between the trigger occurring and the first sample being taken.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>ps2000aIsTriggerOrPulseWidthQualifierEnabled</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status, triggerEnabled, pwqEnabled] = ps2000aIsTriggerOrPulseWidthQualifierEnabled(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');

    % Allocate values for variables
    triggerEnabled = 0;
    pwqEnabled = 0;

    [status, triggerEnabled, pwqEnabled] = calllib('ps2000a', ...
        'ps2000aIsTriggerOrPulseWidthQualifierEnabled', ...
        deviceObj.DriverData.unitHandle, triggerEnabled, pwqEnabled);

    if( status ~= PicoStatus.PICO_OK)

        error('ps2000aIsTriggerOrPulseWidthQualifierEnabled:- status code: %d. Please refer to the PicoStatus.m file.', status); 

    end</MCode>
               </Code>
               <Description>ps2000aIsTriggerOrPulseWidthQualifierEnabled(obj) discovers whether a trigger, or pulse width triggering, is enabled.

Call after setting up the trigger, and just before calling either ps2000aRunBlock, runBlock or ps2000aRunStreaming.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Trigger group.

Output Arguments:

status - status code returned by the device.
triggerEnabled - indicates whether the trigger will successfully be set when ps2000aRunBlock, runBlock or ps2000aRunStreaming is called. A non-zero value indicates that the trigger is set, zero that the trigger is not set.
pwqEnabled - indicates whether the pulse width qualifier will successfully be set when ps2000aRunBlock, runBlock or ps2000aRunStreaming is called. A non-zero value indicates that the pulse width qualifier is set, zero that the pulse width qualifier is not set.</Description>
            </Method>
            <Method>
               <Name>ps2000aSetTriggerChannelConditions</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [status] = ps2000aSetTriggerChannelConditions(obj, conditions, nConditions)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    status = calllib('ps2000a', 'ps2000aSetTriggerDigitalPortProperties', ...
            deviceObj.DriverData.unitHandle, conditions, nConditions);
        
    if( status ~= PicoStatus.PICO_OK)

        error('ps2000aIsTriggerOrPulseWidthQualifierEnabled:- status code: %d. Please refer to the PicoStatus.m file.', status); 

    end</MCode>
               </Code>
               <Description/>
            </Method>
            <Method>
               <Name>ps2000aSetTriggerDigitalPortProperties</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function ps2000aSetTriggerDigitalPortProperties(obj, directions)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    if (deviceObj.DriverData.digitalPortCount &gt; 0)
        
        status = calllib('ps2000a', 'ps2000aSetTriggerDigitalPortProperties', ...
            deviceObj.DriverData.unitHandle, directions, length(directions));
        
        if (status ~= PicoStatus.PICO_OK)
           
            error(['ps2000aSetTriggerDigitalPortProperties: Status code: %d. ' ...
                'Please refer to the PicoStatus.m file.', status); 
            
        end
        
    else
        
        error('PS2000aInstrumentDriver:NonMSODevice', ...
            ['ps2000aSetTriggerDigitalPortProperties: Function not supported ' ...
            'by this device.']);
        
    end</MCode>
               </Code>
               <Description>ps2000aSetTriggerDigitalPortProperties(obj, directions) will set the individual Digital channels trigger directions.

Each trigger direction consists of a channel name and a direction. If the channel is not included in
the array of tPS2000ADigitalChannelDirections structures the driver assumes the digital channel's trigger direction is PS2000A_DIGITAL_DONT_CARE.

Trigger using digital channels is NOT currently supported by this Instrument Driver.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Trigger group.
directions - an array of tPS2000ADigitalChannelDirections structures describing the requested properties. The array can contain a single element describing the properties of one channel, or a number of elements describing several digital channels.

Output Arguments:

status - status code returned by the device.

For further information on the ps2000aSetTriggerDigitalPortProperties function please refer to the PicoScope 2000 Series (A API) PC Oscilloscopes and MSOs Programmer's Guide.</Description>
            </Method>
            <Method>
               <Name>setSimpleTrigger</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setSimpleTrigger(obj, source, thresholdMV, direction)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Find the voltage range index
    % Set default as 5V (External trigger will use this range).
    channelRange = deviceObj.DriverData.enums.enPS2000ARange.PS2000A_5V;

    % Obtain information for device 
    channelSettings = deviceObj.DriverData.channelSettings;
    
    % Range is item 3 in the row for each channel

    switch(source)

        % Channel A
        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_A

            channelRange = channelSettings(1,3);

        % Channel B
        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_B

            channelRange = channelSettings(2,3);

        % Channel C
        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_C

            channelRange = channelSettings(3,3);

        % Channel D
        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_CHANNEL_D

            channelRange = channelSettings(4,3);
            
        % External trigger
        case deviceObj.DriverData.enums.enPS2000AChannel.PS2000A_EXTERNAL
            
            % External trigger has +/-5V range - no need to change.

        otherwise

            error('setSimpleTrigger: Invalid channel specified');

    end
    
    % Obtain the range being used in millivolts
    channelRangeMV = PicoConstants.SCOPE_INPUT_RANGES(channelRange + 1);

    % Calculate the threshold in ADC counts
    thresholdADC = mv2adc(thresholdMV, channelRangeMV, deviceObj.DriverData.maxADCValue);

    status = calllib('ps2000a', 'ps2000aSetSimpleTrigger', ...
            deviceObj.DriverData.unitHandle, PicoConstants.TRUE, source, ...
            thresholdADC, direction, deviceObj.DriverData.delay, ...
            deviceObj.DriverData.autoTriggerMs);
        
    if(status ~= PicoStatus.PICO_OK)
       
        error('setSimpleTrigger:- status code: %d. Please refer to the PicoStatus.m file.', status);
        
    end
</MCode>
               </Code>
               <Description>setSimpleTrigger(obj, source, thresholdMV, direction) simplifies arming the trigger. 

It supports only the LEVEL trigger types and does not allow more than one channel to have a trigger applied to it.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Trigger group.
source - the channel on which to trigger (an enPS2000AChannel enumeration value).
thresholdMV - the level at which the trigger will fire (in millivolts).
direction - direction in which the signal must move to cause a trigger. The following directions are supported: ABOVE, BELOW, RISING, FALLING and RISING_OR_FALLING.

Output Arguments:

status - status code returned by the driver.</Description>
            </Method>
            <Method>
               <Name>setTriggerOff</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function status = setTriggerOff(obj)
% For group functions, OBJ is the group object. For
% base device functions, OBJ is the device object.

    deviceObj = get(obj, 'Parent');
    
    % Set trigger to false for channel A
    
    source = 0; % Channel A
    thresholdADC = 0;
    direction = 0;
    
    status = calllib('ps2000a', 'ps2000aSetSimpleTrigger', ...
            deviceObj.DriverData.unitHandle, PicoConstants.FALSE, source, ...
            thresholdADC, direction, deviceObj.DriverData.delay, ...
            deviceObj.DriverData.autoTriggerMs);
    
    if (status ~= PicoStatus.PICO_OK)
           
        error(['setTriggerOff:- ps2000aSetSimpleTrigger status code %d. ' ...
            'Please refer to the PicoStatus.m file.\n'], status);
        
    end
    
    % Turn off digital trigger for MSO devices
    
    if (deviceObj.DriverData.digitalPortCount &gt; 0)
    
        status = calllib('ps2000a', 'ps2000aSetTriggerDigitalPortProperties', ...
            deviceObj.DriverData.unitHandle, [], 0);
        
        if (status ~= PicoStatus.PICO_OK)
        
            error(['setTriggerOff:- ps2000aSetTriggerDigitalPortProperties status code %d. ' ...
            'Please refer to the PicoStatus.m file.\n'], status);
        
        end
        
    end</MCode>
               </Code>
               <Description>setTriggerOff(obj) switches off triggering on the oscilloscope.

This function may be used with the Test and Measurement Tool.

Input Arguments:

obj - the object representing the Trigger group.

Output Arguments:

status - status code returned by the device.</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>